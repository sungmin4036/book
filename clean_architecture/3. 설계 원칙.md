- [ㅁ 설계 원칙](#ㅁ-설계-원칙)
- [ㅁ SRP: 단일 책임 원칙](#srp-단일-책임-원칙)


---

### ㅁ 설계 원칙

좋은 소프트웨어 시스템은 깔끔한 코드(clean code)로부터 시작한다.

좋은 코드도 중요하지만 그것을 설계하는 아키텍처도 중요하다. 이때 좋은 아키텍처를 정의하는 원칙이 `SOLID`이다.

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다.

클래스라는 단어 사용했다고 해서 객체지향 소프트웨어에만 적용된다는 뜻은 아니다.

여기서에서 클래슨느 단순히 함수와 데이터를 결합한 집합을 뜻한다.

SOLID 원칙의 목적은 중간 수준의 소프트웨ㅓ 구조가 아래와 같도록 만드는데 있다.

- 변경에 유여한다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

'중간 수준'이라 함은 프로그래머가 이들 원칙을 모듈 수준에서 작업할 때 적용할 수 있다는 뜻이다.

즉, 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는 데 도움을 준다.

- SRP: 단일 책임 원칙(Single Responsibility Principle)

: 콘웨이(Cnoway) 법칙에 따른 정리: 소프트웨어 시스템이 가질 수 있는 최적의 구조는 시스템을 만드는 조직의 사회적 구조에 커다란 영향을 받는다.

따라서 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.

<br>

- OCP: 개방-폐쇄 원칙(Open-Closed Principle)

: 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경 할 수 있다는 것

<br>

- LSP: 리소코프 치환 원칙(Liskov Substitution Principle)

: 하위 타입(subtype)에 관한 유명한 원칙으로, 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다.

<br>

- ISP: 인터페이스 분리 원칙(Interface Segregation Priciple)

: 소프트웨어 설계자는 사용하지 않는 것에 의존하지 않아야 한다.

<br>

- DIP: 의존성 역전 원칙(Dependency Inversion Principle)

: 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야 한다.

<br>

### SRP: 단일 책임 원칙

: 함수는 반드시 하나의, 단 하나의 일만 해야 한다는 원칙

이 원칙은 커다란 함수를 작은 함수들로 리팩터링하는 더 저수준에서 사용된다.

역사적으로 SRP는 아래와 같이 기술되어 있다.

```
단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.
```

소프트웨어 시스템은 사용자와 이해관계자를 만족시키기 위해 변경된다.

즉 이렇게 바꿔 말할 수도 있다.

```
하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야 한다.
```

여기서 사용자나 이해관계자는 집단을 가리킨다. 이러한 집단을 액터(actor)라고 부를 예정이다.

이제 SRP 최종 버전이다.

```
하나의 모듈은 하나의 오직 하나의액터에 대해서만 책임져야 한다.
```

모듈이란? 가장 단순한 정의는 바로 소스 파일이다.

대부분의 경우 이 정의는 잘 들어맞지만 일부 언어 및 개발 환경에서는 코드를 소스 파일에 저장하지 않는다. 

이러한 경우 모듈은 단순히 함수와 데이터로 구조로 구성된 응집된 집합이다.

응집된(conhesive)이라는 단어가 SRP를 암시한다. 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성(cohesion)이다.

