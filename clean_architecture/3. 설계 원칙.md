- [ㅁ 설계 원칙](#ㅁ-설계-원칙)
- [ㅁ SRP: 단일 책임 원칙](#srp-단일-책임-원칙)


---

### ㅁ 설계 원칙

좋은 소프트웨어 시스템은 깔끔한 코드(clean code)로부터 시작한다.

좋은 코드도 중요하지만 그것을 설계하는 아키텍처도 중요하다. 이때 좋은 아키텍처를 정의하는 원칙이 `SOLID`이다.

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다.

클래스라는 단어 사용했다고 해서 객체지향 소프트웨어에만 적용된다는 뜻은 아니다.

여기서에서 클래슨느 단순히 함수와 데이터를 결합한 집합을 뜻한다.

SOLID 원칙의 목적은 중간 수준의 소프트웨ㅓ 구조가 아래와 같도록 만드는데 있다.

- 변경에 유여한다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

'중간 수준'이라 함은 프로그래머가 이들 원칙을 모듈 수준에서 작업할 때 적용할 수 있다는 뜻이다.

즉, 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는 데 도움을 준다.

- SRP: 단일 책임 원칙(Single Responsibility Principle)

: 콘웨이(Cnoway) 법칙에 따른 정리: 소프트웨어 시스템이 가질 수 있는 최적의 구조는 시스템을 만드는 조직의 사회적 구조에 커다란 영향을 받는다.

따라서 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.

<br>

- OCP: 개방-폐쇄 원칙(Open-Closed Principle)

: 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경 할 수 있다는 것

<br>

- LSP: 리소코프 치환 원칙(Liskov Substitution Principle)

: 하위 타입(subtype)에 관한 유명한 원칙으로, 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다.

<br>

- ISP: 인터페이스 분리 원칙(Interface Segregation Priciple)

: 소프트웨어 설계자는 사용하지 않는 것에 의존하지 않아야 한다.

<br>

- DIP: 의존성 역전 원칙(Dependency Inversion Principle)

: 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야 한다.

<br>

### SRP: 단일 책임 원칙

: 함수는 반드시 하나의, 단 하나의 일만 해야 한다는 원칙

이 원칙은 커다란 함수를 작은 함수들로 리팩터링하는 더 저수준에서 사용된다.

역사적으로 SRP는 아래와 같이 기술되어 있다.

```
단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.
```

소프트웨어 시스템은 사용자와 이해관계자를 만족시키기 위해 변경된다.

즉 이렇게 바꿔 말할 수도 있다.

```
하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야 한다.
```

여기서 사용자나 이해관계자는 집단을 가리킨다. 이러한 집단을 액터(actor)라고 부를 예정이다.

이제 SRP 최종 버전이다.

```
하나의 모듈은 하나의 오직 하나의액터에 대해서만 책임져야 한다.
```

모듈이란? 가장 단순한 정의는 바로 소스 파일이다.

대부분의 경우 이 정의는 잘 들어맞지만 일부 언어 및 개발 환경에서는 코드를 소스 파일에 저장하지 않는다. 

이러한 경우 모듈은 단순히 함수와 데이터로 구조로 구성된 응집된 집합이다.

응집된(conhesive)이라는 단어가 SRP를 암시한다. 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성(cohesion)이다.

- 서로 다른 액터가 의존하는 코들르 너무 가까이 배치하면 문제가 발생할수 있음. SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.
- 소스 파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생하리라고 짐작하기 어려운 일은 아님. 특히 메서드가 서로 다른 액터를 책임진다면 병할 발생 가능성은 높음

ㅁ 해결책

- 메서드를 각기 다른 클래스로 이동 시키는 방식

: 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식. 즉, 아무런 메서드가 없는 간단한 데이터 구조 클래스를 만들어, 세 개의 클래스가 공유하도록 한다.

각 클래스는 자신이 자신의 메서드에 필요한 소스 코드만 포함한다.

세 클래스는 서로의 존재를 몰라야 한다. 따라서 '우연한 중복' 피할수 있다.

그러나 이 해결책은 개발자가 세 가지 클래스를 인스턴스화 하고 추적해야 한다는 단점이 있다.

이러한 난관은 빠져나올떄 쓴느 흔한 기법이 `퍼사드(Facade)` 패턴이다.

- Facade

: 간단한 데이터 구조 클래스는 세 클래스의 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.

1. 어떤 개발자는 가장 중요한 업부 규칙을 데이터와 가깝게 배치하는 방식을 선호한다. 이 경우 가장 중요한 메서드는 기존 클래스 그대로 유지하되, 덜 중요한 나머지 클래스들에 대한 퍼사드로 사용할 수도 있다.

2. 모든 클래스는 반드시 단 하나의 메서드를 가져야한다는 주장에 그거하여 앞의 해결책을 반대할 수 도 있다. 하지만 이 주장은 각 클래스에 지불, 보고서 생성, 데이터 저장 기능 구현하는데 필요한 메서드의 개수는

실제로 훨씬 더 많을 것이다. 이들 클래스는 모두 다수의 private 메서드를 포함할 것이다.

이처럼 여러 메서드가 하나의 가족을 이루고, 메서드의 가족을 포함하는 각 클래스는 하나의 유효버무이가 된다. 해당 유효범위 바깥에서는 이 가족에게 감춰진 식구(private 멤버)가 있는지 알수 없다.

ㅁ 결론

단일 책임 원칙은 메서드와 클래스 수준의 원칙이다. 하지만 더 상위의 두 수준에서도 다른 형태로 다시 등장한다.

컴포넌트 수준에서는 공통 폐쇄 원칙(Common Closure Priniciple)

아키텍처 수준에서는 아키텍처 경계(Architectural Boundary)의 생성을 책임지는 변경의 축(Axis of Change)이 된다.

<br>
<br>

### ㅁ OCP: 개방-폐쇄 원칙

소프트웨어 개체(artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.

즉, 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이 때 개체를 변경해서는 안 된다.

How? 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고(단일 책임 원칙SRP), 이들 요소 사이의 의존성을 체계화함으로써(의존성 역전 원칙DIP) 변경량 최소화 할 수 있다.

- 책임을 분리하고, 그 책임중 변경이 발생하더라고 다른 책임에는 변경되지 않도록 소스 코드 의존성도 확실히 조직화 해야 한다.

또한 새로 조직화한 구조에서는 행위 확장될 떄 변경이 발생하지 않음을 보장해야 한다.

이러한 목적을 달성하려면 처리 과정을 클래스 단위로 분할하고, 이들 클래스를 컴포넌트 단위로 구분해야 한다.

- A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야 한다.

- 아키텍처 수준에서  OCP가 동작하는 방식은, 아키텍트는 기능이 어떻게(how), 왜(why), 언제(when) 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화 한다.

컴포넌트 계층구조를 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.

- 방향성 제어

- 정보 은닉, 추이 종속성을 가지게 되면 소프트웨어 '엔티티는 자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다'는 소프트웨어 원칙을 위반하게 된다.

- OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 많은 영향을 받지 않도록 하는 데 있다. 이러한 목표 달성 위해서는 시스템을 컴포넌트 단위로 분리하고,

저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보홀할 수 있는 형태의 `의존성 계층구조`가 만들어지도록 해야한다.

<br>
<br>

### ㅁ LSP: 리스코프 치환 원칙

LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다. 치환가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문인다.

<br>
<br>

### ㅁ IPS: 인터페이스 분리 원칙

정적 타입 언어는 사용자가 import, use, include와 같은 타입 선언문을 사용하도록 강제한다. 이처럼 소스 코드에 '포함된' 선언문으로 인해 소스 코드 의존성이 발생하고,

이로 인해 재 컴파일 또는 재배포가 강제되는 상황이 무조건 초래된다.

루비나 파이썬같은 동적 타입 언어에서는 이러한 선언문이 존재하지 않는다. 대신 런타임에 추론이 발생한다. 따라서 소스 코드의 의존성이 아예 없으며,  재컴파일과 재배포가 필요없다. 

동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때 보다 유연하며 결합도가 낮은 시스템을 만들 수 있는 이유는 바로 이 때문이다.

이러한 사실로 인해 ISP를 아키텍처가 아니라, 언어와 관련된 문제라고 결론 내릴 여지가 있다.

일반적으로 필요 이상의 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다.

소스 코드 의존성의경우 이는 분명한 사실인데, 불필요한 재컴파일과 재배포를 강제하기 떄문인다.

하지만 더 고수준인 아키텍처 수준에서도 마찬가지인 상황이다.

<br>
<br>

### ㅁ DIP: 의존성 역전 원칙

DIP 에서 말하는 유연성이 극대화된 시스템이란 소스코드 의존성이 추상(abstraction)에 의존하며 구체(concretion)에는 의존하지 않는 시스템이다.

정적타입 언어에서는 이 말은 use, import, include 구문은 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 뜻이다.

구체적인 대상에는 절대로 의존해서는 안 된다.

동적 타입 언어도 동일한 규칙이 적용된다. 소스 코드 의존 관계에서 구체 모듈은 참조해서는 안된다.

DIP를 논할 때 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다.

변경되지 않는다면 의존할 수 있다는 사실을 알고 있기 떄문에 이러한 환경에 대해서는 용납한다.

우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰(volatile)구체적인 요소다.

이 구체적인 요소는 우리가 열심히 개발하는 중이라 자주 변경될 수 밖에 없는 모듈들 이다.

뛰어난 소프트웨웨어 설계자와 아키텍트라면 인터페이스의 변동성을 낮추기 위해 애쓴다. 이는 소프트웨어 설계의 기본이다.

즉, 안정된 소프트웨어 아키텍처란 변동이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻이다.

- 변동성이 큰 구체 클래스를 참조하지 말라. 대신 추상 인터페이스를 참조하라.

이 규칙은 언어가 정적 타입이든 동적타입이든 관계없다. 이 규칙은 객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리(Abstract Factory)를 사용하도록 강제한다.

- 변동성이 큰 구체 클래스로부터 파생하지 말라.

정적 타입 언어에서 상속은 소스 코드에 존재하는 모든 관계 중에서 가장 갈력한 동시에 뻣뻣해서 변경하기 어렵다. 따라서 상속은 아주 신중하게 사용해야 한다.

동적 타입 언어라면 문제가 덜 되지만, 의존성을 가진다는 사실에는 변함이없다.

- 구체 함수를 오버라이드 하지 말라.

대체로 구체 함수는 소스 코드 의존성을 필요로 한다. 따라서 구체 함수를 오버라읻 ㅡ하면 이러한 의존성을 제거할 수 없게 되며,

실제로 그 의존성을 상속하게 된다. 이러한 의존성을 제거하려면, 차라리 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.

- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.

<br>

- 팩토리

모든 언어에서 객체를 생성하려면 해당 객체를 구체적으로 정의한 코드에 대해 소스 코드 의존성이 발생한다.

자바 등 대다수의 객체 지향 언어에서 이처럼 바람직하지 못한 의존성을 처리할 떄 추상 팩토리를 사용하곤 한다.

그림 11.1 에서의 곡선은 아키텍처 경계를 뜻한다. 이 곡선은 추상 컴포넌트와 구체 컴포넌트를 분리한다.

소스 코드 의존성은 해당 곡선과 교찰할 때 모두 한 방향, 즉 추상적인 쪽으로 향한다.

추상 컴포넌트는 애플리케이션의 모든 고수준 업무 규칙을 포함한다.

구체 컴포넌트는 업무 규칙을 다루기 위해 필요한 모든 세부사항을 포함한다.

제어 흐름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지른다. 이러한 이유로 이 원칙을 의존성 역전(Dependency Inversion) 이라고 부른다.

<br>

- 구체 컴포넌트

DIP 위배를 모두 없앨 수는 없다. 하지만 DIP를 위배하는 클래스 들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과는 분리할 수 있다.

대다수의 시스템은 이러한 구체 컴포넌트를 최소한 하나는 포함할 것이다. 흔히 이 컴포넌트를 메인(Main)이라고 부르는데, main 함수를 포함하기 떄문이다.

<br>

그림 11.1 의 곡선은 이후의 장에서는 아키텍처 경계가 될 것이다. 그리고 이 의존성은 이 곡선을 경계로 더 추상적인 엔티티가 있는 쪽으로만 향한다.

추후 이 규칙은 의존성 규칙(Dependncy Rule)이라고 부를 것이다.