- [ㅁ 패러다임의 개요](#ㅁ-패러다임의-개요)
- [ㅁ 구조적 프로그래밍](#ㅁ-구조적-프로그래밍)
- [ㅁ 객체 지향 프로그래밍](#ㅁ-객체-지향-프로그래밍)
- [ㅁ 함수형 프로그래밍](#ㅁ-함수형-프로그래밍)
---

### ㅁ 패러다임의 개요

- 구조적 프로그래밍
: 최초로 적영된 패러다임으로, 무분별한 점프(goto 문장)는 프로그램 구조에 해롭다는 사실 제시

추후 if/then/else 와 do/while/until 과 같은 구조로 대체됨.

구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과

<br>

- 객체 지향 프로그래밍
: 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과

<br>

- 함수형 프로그래밍
: 함수형 프로그래밍은 할당문에 대해 규칙을 부과

<br>

### ㅁ 구조적 프로그래밍

: goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 사실 발견

goto문의 '좋은' 사용 방식은 if/then/else 와 do/while과 같은 분기와 반복이라는 단순한 제어 구조에 해당한다는 사실을 발견

모듈이 이러한 종류의 제어 구조만 사용한다면 증명 가능한 단위로까지 모듈을 재귀적으로 세분화 하는것이 가능해 보였다.

이러한 제어 구조는 순차 실행(sequential execution)과 결합했을 때 특별 하다는 사실 발견.

모든 프로그램은 순차(sequence), 분기(selection), 반복(iteration) 이 세 가지 구조만으로 표현 할수 있다는 사실 증명.

현재의 우리 모두는 구조적 프로그래머 이며, 제어흐름을 제약 없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않기 때문

- 테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다.

테스트가 보장할 수 있는 것은 프로그램이 목표에 부합할 만큼 충분히 참이라고 여길 수 있게 해주는 것이 전부 이다.

- 결론: 구조적 프로그래밍이 오늘날까지 가치가 있느 이유는 프로그래밍에서 반증 가능한 `단위`를 만들어 낼 수 있는 능력 떄문

가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 `반증 가능성`에 의해 주도된다.

소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 노력해야 한다.

이를 위해서 구조적 프로그래밍과 유사한 제한적인 규칙들을 받아들여 활용해야 한다.

<br>

### ㅁ 객체 지향 프로그래밍

: 좋은 아키텍처를 만드는 일은 객체 지향(Object-Oriented) `데이터와 함수의 조합` 설계 원칙을 이해하고 응요하는 데서 출발한다.

본질을 설명하기 위해서, 캡슐화(encapsulation), 상속(Inheritance), 다형성(polymorphism) 최소한 이 세 가지 요소를 반드시 지원해야 한다.

<br>

- 캡슐화

: 캡슐화는 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 ㅇㅇ언어가 제공하기 때문이다. 그리고 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다.

구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출 된다.

C언어 에서는 먼저 데이터 구조와 함수를 헤더 파일에 선언하고, 구현 파일에서 이들을 구현한다. 그리고 프로그램 사용자는 구현 파일에 작성된 항목에 대해서는 접근 불가능 하다.

C++ 등장이후 C언어의 완전한 캡슐화가 깨졌다.

C++ 컴파일러는 기술적인 이유로 클래스의 멤버 변수를 해당 클래스의 헤더 파일에 선언하는 것을 요구 했다.

언어에 public, private, projected 키워들 도이합여 불완전한 캡슐화를 어느 정도 보완하기는 했다. 하지만 이는

컴파일러가 헤더 파일에서 멤버 변수를 볼 수 있어야 했기 떄문에 조치한 임시 방편일 뿐이다.

JAVA와 C#은 헤더와 구현체를 분리하는 방식 모두 버렸고, 이로 인해 캡슐화는 더욱 심하게 훼손 되었다.

ㅇㅇ 언어에서는 클래스 선언과 정의를 구분하는 게 아예 불가능

이 때문에 강력한 캡슐화를 의존한다는 정의는 받아 들이기 힘들다. 실제로 많은 언어가 캡슐화를 거의 강제하지 않는다.

<br>

- 상속

: ㅇㅇ언어가 더 나은 캡슐화를 제공은 못했지만, 상속만큼은 ㅇㅇ언어가 확실히 제공했다.

하지만 상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다.

<br>

- 다형성

: 유닉스 운영체제의 경우 모든 입출력 장치 드라이버가 5가지 표준 함수를 제공할 것을 요구한다.

열기(open), 닫기(close), 읽기(read), 쓰기(write), 탐색(seek)

FILE 데이터 구조는 이 다섯 함수를 가리키는 포인터들을 포함한다.

위 단순한 기법이 모든 ㅇㅇ가 지닌 다형성의 근간이 된다.

C++에서는 클래스의 모든 가상 함수(virtual funcion)는 vtable이라는 테이블에 포인터를 가지고 있고,

모든 가장 함수 호출은 이 테이블을 거치게 된다. 파생 클래스의 생성자는 생성하련느 객체의 vtable을 단순히 자신의 함수들로 덮어 쓸 뿐이다.

말하려는 요지는 `함수를 가리키는 포인터를 응용한 것이 다형성`이라는 점이다.

함수에 대한 포인터를 직접 사용하여 다형적 행위를 만드는 이 방식에는 문제가 있는데, 함수 포인터는 위험하다는 사실이다.

이러한 기법은 프로그래머가 특정 관례를 수동으로 따르는 방식

즉, 이들 포인터를 초기화하는 관례를 준수해야 한다는 사실을 기억해야 한다.

그리고 이들 포인터를 통해 모든 함수를 호출하는 관례를 지켜야 한다는 점도 기억해야 한다.

만약 관례를 안지킬시 버그가 발생하며, 버그를 찾아내고 오개는것도 힘들다.

ㅇㅇ언어는 이러한 관례를 없애주며, 실수할 위험이 없다. ㅇㅇ언어를 사용하면 다형성은 대수롭지 않은 일이 된다.

ㅇㅇ는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있다.

<br>

- 다형성이 가진 힘

: 플러그인 아키텍처(plugin architecture)는 입출력 장치 동립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다.

그럼에도 대다수의 프로그래머는 직접 장성하는 프로그램에서는 이러한 개념을 확장하여 적용하지 않았는데, 함수를 가리키는 포인터를 사용하면 위험을 수반하기 떄문이다.

ㅇㅇ의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.

<br>

- 의존성 역전

: 다형성 안전하고 편리하게 적용가능한 메커니즘 등장하기 전에는 전형적인 호출 트리의 경우

main함수가 고수준 함수를 호출하고, 고수준 함수가 다시 중간 수준 함수를 호출하며, 중간 수준 함수는 다시 저수준 함수를 호출한다.

이러한 호출트레이서 소스 코드 의존성의 방향은 반드시 제어흐름(flow of control)을 따르게 된다.

main 함수가 고수준 함수 호출할려면 고수준 함수가 포함된 모듈의 이름을 지정해야만 한다.

C언어는 #include, JAVA는 import, C#은 using 구문이다.

이러한 제약 조건으로 제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 제어흐름에 따라 결정된다.

하지만 다형성이 끼어들면 특별한 일이 일어난다.

ㅇㅇ언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드의 의존성을 어디에서든 역전시킬 수 있다는 뜻이기도 하다.

이러한 소스 코드 의존성은 소스 코드 사이에 인터페이스를 추가함으로써 방향을 역전시킬 수 있다.

이러한 접근법을 사용하면, ㅇㅇ언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 갖는다.

즉, 소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 갖는다.

즉, 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다.

그리고 이것이 바로 ㅇㅇ가 지향하는 것.

ex) 업무 규칙이 DB와 UI에 의존하는 대신에, 시스템의 소스 코드 의존성을 반대로 배치하여, DB와 UI가 업무 규칙에 의존하게 만들 수 있다.

즉, UI와 DB가 업무 규칙의 플러그인이 된다는 뜻이다.

다시 말해 업무 규칙의 소스 코드에서는 UI나 DB를 호출하지 않는다.

결과적으로 업무 규칙, UI, DB는 세 가지로 분리된 컴포넌트 또는 배포 가능한 단위로 컴파일 할수 있고, 이 배포 단위들의 의존성 역시 소스 코드 사이의 의존성과 같다.

따라서 업무 규칙을 포함하는 컴포넌트와 UI와 DB를 포함하는 컴포넌트에 의존하지 안흔다.

따라서 업무 규칙을 UI와 DB와는 독립적으로 배포 가능.

다시 말해 특정 컴포넌트의 소스 코드가 변경된면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다. 이것이 바로 `배포 독립성(Independet deployability)`

시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각각 모듈을 독립적으로 개발할 수 있다. 이것이 `개발 독립성(Independent developability)`

ㅇㅇ란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획들할 수 있는 능력이다.

ㅇㅇ를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고 이를 통해 고수준의 정책을 포함하는 모델은 저수준의 세부사항을 포함하는 모듈에 대해 독립성 모장 가능.

저수준의 세부사항은 중요도가 낮은 프러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할수 있다.

<br>

### ㅁ 함수형 프로그래밍

: 이 패러다임에서 핵심이 되는 기반은 람다(lambda) 계산법으로 알론조 처치(Alonzo Church)가 1930년대에 발명

함수형 언어에서는 변수는 변경되지 않는다.

아키텍트는 왜 변수의 가변셩을 염려하는 이유는? 경합(race)조건, 교착상태(deadlock)조건, 동시 업데이트(concurrent update) 문제가 모두 가변 변수로 인해 발생하기 때문.

아키텍트라면 동시성(concurrency) 문제에 지대한 관심을 가져야만 한다.

불변성이 가능할려면 저장 공간이 무한하고 프로세서의 속도가 무한히 빠르다는 전제하에 가능, 즉 일종의 타협이 필요

<br>

- 가변성 분리

: 불변성과 관련하여 가장 주요한 타협 중 하나는 애플리케이션 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.

불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다.

불변 컴포넌트는 변수의 상태를 변경할수 있는, 즉 숙수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다.

상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 꼴이므로, 흔히 트랜잭션 메모리(transactional memory)와 같은 실천법을 사용하여 동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호한다.

트랜잭션 메모리는 데이터베이스가 디스크의 레코드를 다루는 방식과 동일한 방식으로 메모리의 변수를 처리한다.

즉, 트랜잭션을 사용하거나 또는 재시도 기법을 통해 이들 변수를 보호한다.

하지만 이러한 방식으로는 여러 변수가 상호 의존하는 상황에서는 동시 업데이트와 교착상태 문제로부터 환벽히 보호 불가능.

애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야한다.

그리고 이렇게 분리하려면 가변 변수들은 보호하는 적절한 수단을 동원해 뒷받침해야 한다.

가능한 많은 처리를 불변 컴포넌트로 옮겨야하고, 가변 컴포넌트는 가능한 코드에서 뺴내야 한다.

<br>

- 이벤트 소싱

: 저장 공간과 처리 능력은 점점 좋아지고, 필요한 가변 상태는 더 적어진다.

이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다.

상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.

저장 고간이 많이 필요하지만, 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없다는 사실이다.

결과적으로 애플리케이션은 CRUD가 아니라 그저  CR 만 수행한다.

또한 데이터 저장소에서 변경과 삭제가 전혀 발생하지 않으므로 동시 업데이트 문제도 일어나지 않는다.

저장 공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있고, 따라서 완전한 함수형으로 만들 수 있다.

<br>

위 3개의 패러다임은 우리가 코드를 작성하는 방식의 형태를 한정시킨다.

어떤 패러다임도 우리의 권한이나 능력에 무언가를 보태지 않고 한정만 시키고 있다.

즉, 소프트웨어는 발전하는 기술이 아니라는 것이다.

소프트웨어는 최초의 코드를 작성할 때 사용한 규칙과 지금의 규칙은 조금도 다르지 않다.

소프트 웨어의 핵심은 여전히 그대로 이다.

소프트웨어, 즉 컴퓨터 프로그램은 순차(sequence), 분기(selection), 반복(iteration), 참초(indirection)로 구성 된다.