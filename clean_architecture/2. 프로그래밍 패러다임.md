- [ㅁ 패러다임의 개요](#ㅁ-패러다임의-개요)
- [ㅁ 구조적 프로그래밍)](#ㅁ-구조적-프로그래밍)

---

### ㅁ 패러다임의 개요

- 구조적 프로그래밍
: 최초로 적영된 패러다임으로, 무분별한 점프(goto 문장)는 프로그램 구조에 해롭다는 사실 제시

추후 if/then/else 와 do/while/until 과 같은 구조로 대체됨.

구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과

<br>

- 객체 지향 프로그래밍
: 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과

<br>

- 함수형 프로그래밍
: 함수형 프로그래밍은 할당문에 대해 규칙을 부과

<br>

### ㅁ 구조적 프로그래밍

: goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 사실 발견

goto문의 '좋은' 사용 방식은 if/then/else 와 do/while과 같은 분기와 반복이라는 단순한 제어 구조에 해당한다는 사실을 발견

모듈이 이러한 종류의 제어 구조만 사용한다면 증명 가능한 단위로까지 모듈을 재귀적으로 세분화 하는것이 가능해 보였다.

이러한 제어 구조는 순차 실행(sequential execution)과 결합했을 때 특별 하다는 사실 발견.

모든 프로그램은 순차(sequence), 분기(selection), 반복(iteration) 이 세 가지 구조만으로 표현 할수 있다는 사실 증명.

현재의 우리 모두는 구조적 프로그래머 이며, 제어흐름을 제약 없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않기 때문

- 테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다.

테스트가 보장할 수 있는 것은 프로그램이 목표에 부합할 만큼 충분히 참이라고 여길 수 있게 해주는 것이 전부 이다.

- 결론: 구조적 프로그래밍이 오늘날까지 가치가 있느 이유는 프로그래밍에서 반증 가능한 `단위`를 만들어 낼 수 있는 능력 떄문

가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 `반증 가능성`에 의해 주도된다.

소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 노력해야 한다.

이를 위해서 구조적 프로그래밍과 유사한 제한적인 규칙들을 받아들여 활용해야 한다.

