### - 디자인 원칙과 단위 테스트

: 단위 테스트는 다른 코드의 일부분이 유효한지 검사하는 코드.

단위 테스트는 비즈니스 로직이 특정 조건을 보장하는지를 확인하기 위해 여러 시나리오를 검증하는 코드

ㅁ 단위테스트 특징

- 격리: 단위 테스트는 다른 외부 에이전트와 완전히 독립적이어여 하며 로직에만 집중해야한다. 때문에 DB 연결하지 않고, HTTP 요청도 하지 안항야 한다. 격리는 또한 테스트 자체가 독립적이라는 것을 의미. 테스트는 이전 상태에 관계없이 임의의 순서로 실행될 수 있어야 한다.

- 선능: 단위 테스트는 신속하게 실행되어야 한다. 반복적으로 여러 번 실행될 수 있도록 설계해야 한다.

- 자체 검증: 단위테스트의 실행만으로 결과를 결정할 수 있어야 한다. 단위 테스트를 처리하기 위한 추가 단계가 없어야 한다.


---

### - 자동화된 테스트의 다른 형태

: 단위 테스트는 함수 또는 메서드와 같은 매우 작은 단위를 확인하기 위한 것.

단위 테스트는 최대한 자세하게 코드를 검사하는 것이 목적

클래스를 테스트하려면 단위 테스트가 아니라 단위 테스트의 집한인 테스트 스위트(test suite)를 사용

테스트 스위트를 구성하는 테스트들은 메서드처럼 보다 작은 것을 테스트 한다.

- 통합 테스트에서는 한 번에 여러 컴포넌트를 테스트한다. 종합적으로 예상대로 잘 동작하는지 검증한다.

이 경우에는 부작용이나 격리 고려 않하고 한다.(HTTP 요청을 하거나 DB 연결등 작업 수행 하는것이 가능 떄로는 이렇게 하는것이 바람직)

- 인수 테스트는 유스케이스(use case)를 활용하여 사용자 관점에서 시스템의 유효성을 검사하는 자동화된 테스트

이 두가지 테스트를 하면 시간이 많이 걸리게 되서 이러한 테스트는 덜 실행하게 된다.

좋은 개발 환경을 구축했다면 테스트 스위트를 만들고 코드에 수정 생길 떄마다 반복적으로 단위 테스트와 리팩토링을 할 수 있어야한다.

단위 테스트는 항상 수행되길 원하지만 통합 테스트나 인수 테스트는 그보다 덜 자주 수행되길 바란다.

이런 이유는 전략적으로 단위 테스트에서 작은 기능을 많이 테스트 하고, 단위 테스트에서 확인할 수 없는 부분을(ex DB) 다른 자동화된 테스트에서 커버하려고 하기 떄문

---

### - 단위 테스트와 애자일 소프트웨어 개발

: 정상 작동한다는 공식적인 증거가 있어야 효율적으로 개발 진행이 가능하게 된다.

이것에 대한 증거는 단위 테스트를 통해 얻을수 있고, 좋은 테스트를 가질수록 버그에 의해 프로젝트를 중단하지 않고 신속하게 가치를 제공할 가능성이 높아진다.

---

### - 단위 테스트와 소프트웨어 디자인

: 좋은 스프트웨어는 테스트 가능한 소프트웨어

테스트의 용이성은 단수히 좋은 것이 아니라 클린 코드의 핵심 가치

단위 테스트는 기본 코들르 보완하기 위한 것이 아닌 실제 코드의 작성 방식에 직접적인 영향을 미치는것

만약 메서드가 크다면 모의과정에서 불필요한 것들을 더 많이 실행해야하기 때문에 메서드를 작게 만들어야 한고, 이것은

테스트 가능성과 관련해 좋은 디자인 이라고 할수 있다.

---

### - 테스트를 위한 프레임워크와 도구

- uniitest
- pytest
- coverage: 테스트 도중 코드의 어떤 부분이 실행되었는지 알려줌
- mock의 객체

: 테스트 시나리오 다루는 것은 uniitest만으로 충분, 그러나 외부 시스템에 연결하는 등의 의존성 필요시 픽스처(fixture)라는 패치 객체 필요. 이렇게 복잡한 옵션이 필요시 pytest 적합

단위 테스트에서 말하는 테스트 더블(test double)은 여러가지 이유로 테스트 스위트에서 실제 코드를 대신해 실제인 것처럼 동작하는 코드를 말함.

실제 상용코드는 필요 없거나 특정 서비스에 접근해야 하는데 권한이 없거나 부작용이 있어서 단위 테스트에서 실행하고 싶지 않은 경우 등

---

### - 리팩토링

: 리팩토링은 소프트웨어 유지 관리에서 중요한 활동이지만 단위 테스트가 없다면 정확성을 보장 어려움

언제든 새로운 기능을 의도한 대로 지원 가능해야한다.

이러한 요구사항 수용할 수 있는 유일한 방법은 코드를 리팩토링하여 일반적인 형태로 만들어야한다.

일반적인 코드 리팩토링 이유는 가독성을 높이려는 경우가 있다. 중요한점은 수정 전후 기능을 유지 해야 한다.

즉 고객 관점에서는 아무 일도 일어나지 않은 것처럼 느껴져야 하낟.

이전과 같은 기능을 지원할 때에만 다른 코드를 사용할 수 있다는 것은 수정된 코드에 대해 회귀(regression) 테스트를 실행해야 함을 의미.

유일한 효율적인 방법은 테스트를 자동화 하는것이며, 자동 테스트의 가장 효율적인 방법이 단위 테스트

---

### 속성 기반 테스트

: 속성 기반(Property-based) 테스트는 테스트를 실패하게 만드는 데이터를 찾는것.

`hypothesis` 라이브러리 이용

---

### 변형 테스트

: 테스트는 작성한 코드가 정확하다는것을 입증해줄 고익적인 확인 방법.

이 테스트가 정확한지 확인하는 방법은 상용코드를 사용하는 것

단위 테스트를 작성하는 이유는 버그로부터 코드를 보호하고 서비스 중에 발생 해서는 안되는 실패에 대해 미리 검증하기 위한 것이다.

변형 테스트 도구를 사용하면 원래 코드를 변경한 새로운 버전(돌연변이, mutant라고 함)으로 코드가 수정된다.

좋은 테스트 스위트는 이러한 돌연변이를 죽여야 하는데, 이런 경우 세트에 의지할 수 있음을 의미한다.

`mutpy` 테스트 도구

---

### - 테스트 주도 개발 전략 소개

: TDD(Test-Driven Development) 의 주요 요점은 기능의 결함으로 실패하게 될 테스트를 상용화 전에 미리 작성해야 한다.

단위 테스트를 먼저 작성한 다음에 코드를 작성하기 때문에 기본적인 기능 테스트 누락할 가능성 매우 낮아짐.

이작의 구성은 단위 테스트 작성한다. 여기서 테스트 실행시 기능이 아직 구현되지 않기 때문에 실패할 것이다.

그런 다음 해당 조건 충족 시키는 최소한의 필수 코드를 구현하고 테스트 다시 실행 이번에는 테스트 통과해야 한다. 

그리고 리팩토링을 통해 코드를 개선한다.

이러한 사이클이 `red-green-refactor` 이다.
   