### - 파이썬에 디자인 패턴 적용 시 고려사항

: 파이썬의 특성중 하나는 디자인 패턴중 일부를 실제로 사용하지 않음, 이미 파이썬은 내부적으로 디자인 패턴을 구현하고 있기 때문

즉, 이미 파이썬에서 추상화한 패턴 중 일부를 인지하고 이를 확용할 수 있는 방법을 터득하는 것

ex) 이터레이션 패턴을 적접 구현하려고 시도하는 것은 파이썬 스럽지 않은것.

지금까지 살펴본 것처럼 클래스는 파라미터로 전달, 데코레이팅, 재할당 하는것이 가능. 가능 객체에 어떤 종류의 커스터마이징을 하더라도 특별한 팩토리 클래스가 없다.

또한 파이썬에서 객체를 생성하기 위한 특별한 구문 없다. 때문에 대부분의 경우 간단한 함수 호출은 팩토리 처럼 동작한다.

---

### - 실전 속의 디자인 패턴

: 각 패턴은 생성(creational), 구조(structural), 행동(behavioral) 패턴 중의 하나로 분류된다.

이것들의 확장 버전이나 변형 버전의 패턴도 존재.

- 주요 염두할점

1. 일부 패턴은 파이썬 내부에서 자체적으로 구현되어 있으므로 보이지 않은 채로도 적절히 적용될 수 있음
2. 모든 패턴이 똑같이 일반적인 것은 아니라는 점

애플리케이션의 솔루션에 강제로 디자인 패턴을 적용해서는 안 되며, 패턴이 출현할 떄까지는 솔루션을 진화시키고 리팩토링하고 개선해야만 한다.

따라서 디자인 패턴은 발명되는 것이 아닌 `발견`되는것

코드에 반복적으로 같은 내용이 출현할 때 비로소 일반적이고 추사오하된 클래스, 객체 또는 컴포넌트의 패턴이 발견되는 것

디자인 패턴은 상황을 설명할 수 있는 언어를 제공한다.

---

### - 생성(creational) 패턴

: 소프트웨어 공학에서 생성 패턴은 객체를 인스턴스화 할 떄의 복잡성을 최대한 추상화하기 위한 것

객체 초기화를 위한 파라미터를 결정하거나 초기화에 필요한 관련 객체를 준비하는 것등의 모든 관련 작업을 단순화하려는 것

이를 통해 더 간단한 인터페이스 제공가능, 사용자는 보다 안전하게 객체 생성 가능

<br>

- 팩토리
: 파이썬의 핵심 기능 중 하나는 모든 것이 객체라는 것이며 따라서 모두 똑같이 취급될 수 있다는 것.

즉, 클래스, 함수 또는 사용자 정의 객체 각각이 역할이 특별히 구분되어 있지 않다. 이들은 모두 파라미터나 할당 등에 사용 가능

이러한 이유로 파이썬에서 팩토리 패턴이 별로 필요하지 않다. 간단히 객체들을 생성할 수 있는 함수를 만들 수 있으며, 생서하련느 클래스를 파라미터로 전달도 가능

<br>

- 싱글턴과 공유 상태(monostate)
: 싱글턴 패턴은 파이썬에 의해 완전히 추상화되지 않은 패턴이다.

사실 대부분의 경우 이 패턴은 실제로 필요하지 않거나 나쁜 선택

싱글턴에는 많은 문제가 있다. 이것은 객체 지향 소프트웨어를 위한 전역 변순의 한 형태이며 결국 나쁜 습관

싱글턴은 단위 테스트가 어려움. 어떤 객체에 의해서 언제든지 수정될 수 있다는 사실은 에측하기 어렵다는 뜻이고, 실제로 부작용이 큰 문제를 일으킬 수 있음

일반적으로 싱글턴은 사용하지 않는 것이 좋다. 극단적으로 꼭 필요한 경우에는 모듈을 사용 하는것이 좋다.

모듈에 객체를 생성할 수 있으며, 모듈은 임포트한 모든 곳에서 사용할 수 있다. 파이썬에서 모듈은 이미 싱글턴이라는 것을 의미. 즉 여러 번 임포트하더라고 sys.moduels에 로딩되는 것은 항상 한 개다.

<br>

- 공유상태
: 객체가 어떻게 호출, 생성 또는 초기화 되는지에 상관없이 하나의 인스턴스만 갖는 싱글턴을 사용하는 것보다 여러 인스턴스에서 사용할 수 있도록 데이터를 복제하는 것이 좋다.

모노 스테이트 패턴(SNGMONO)의 주요 개념은 싱글턴인지 아닌지에 상관없이 일반 객체처럼 많은 인스턴스를 만들 수 이썽야 한다는 것이다.

이 패턴의 장점은 완전히 투명한 방법으로 정보를 동기화하기 때문에 사용자는 내부에서 어떻게 동작하는지 전혀 신경쓰지 않아도 된다.

따라서 이 패턴을 사용하는것이 에러 사용 편하고, 에러 발생 가능성 적고 싱글패턴의 단점으로 인한 고생 덜하기 가능.
(싱글턴의 단점은 테스트가 어렵고 파생 클래스 만들기 어려운 것 등)

얼마나 많은 정보 동기화 하는지에 따라 다양한 수준으로 이 패턴 사용 가능

<br>

ex) 모든 인스턴스에 하나의 속성만 공유 필요한 경우

클래스 변수를 사용하는 것처럼 쉽게 구현 가능하지만 속성의 값을 업데이트하고 검색하는 올바른 인터페이스를 제공해야 한다.


더 많은 속성이 필요하거나 공유 속성ㅇ르 좀 더 캡슐화하고 싶다면 깔끔한 디자인을 위해 디스크립터 사용, 뿐만 아니라 디스크립터를 사용함으로써 재사용성 또한 높아짐

만약 이 로직을 반복시 새로운 디스크립터 객체를 멤버로 만들기만 하면 된다. DRY 원칙 자연스럽게 준수

이 솔루션의 또 다른 중요한 이점은 단위 테스트의 반복을 줄일 수 있다. 모든 클래스를 데스트할 필요 없이 디스크립터 객체에 대해서만 테스트 하면 되기 떄문

---

### - borg 패턴

: 이전의 솔루션은 대부분의 경우에 잘 작동하지만 꼭 싱글턴을 사용해야하는 경우라면 더 나은 대안이 있다.

모노 스테이트 패턴으로 파이썬에서는 `borg` 패턴이라고 부른다.

주요 개념은 같은 클래스의 모든 인스턴스가 모든 속성을 복제하는 객체를 만드는것

모든 속성이 완벽하게 복제된다는 것은 부작용 또한 염두에 둬야 한다는 것을 뜻한다.

그렇지만 여전히 이 패턴은 싱글턴보다 많은 장점을 가지고 있다.

borg 로직을 구현하려면 속성을 저장할 사전을 클래스 속성으로 지정하고, 객체를 초기화시 모든 객체에서 바로 이동일한 사전을 참조하도록 해야한다.

사전은 레퍼런스 형태로 전달되는 변경 가능한 mutable 객체이므로 한 곳에서 사전을 업데이트 하면 모든 객체에 동일하게 업데이트 된다.

의도치 않게 다른 클래스의 객체에도 영향을 미칠 수 있으므로 기본 클래스에 사전과 관련된 로직을 추가하면 안 된다는 점 주의 필요

이때문에 패턴보다는 관용구에 가깝다고 생각한다.

---

### - 빌더

: 빌더 패턴은 객체의 복잡한 초기화를 추상화하는 패턴. 이 패턴은 언어의 특수성에 의존하지 않음

디스크립터와 마찬가지로 여러 사용자가 사용하는 API 같은 것을 노출하는 경우에만 구현해야 한다.

이 패턴은 필요로 하는 모든 객체를 직접 생성해주는 하나의 복잡한 객체를 만들어야 한다.

사용자가 필요로 하는 모든 보조 객체를 직접 생서하여 메인 객체에 전달하는 것이 아닌, 한 번에 모든 것을 처리해주는 추상화를 해야 한다.

빌더 객체는 필요한 모든 것들을 어떻게 생성하고 연결하는지 알고 있다. 빌더 객체는 클래스 메서드와 같은 사용자 인터페이스 제공하며, 사용자는 최종 객체에 대한 모든 정보를 해당 인터페이스에 파라미터로 전달하면 된다.

---

### - 구조(structural) 패턴

: 구조 패턴은 인터페이스를 복잡하게 하지 않으면서도 기능을 확장하여 더 강력한 인터페이스 또는 개체를 만들어야 하는 상황에 유용

이 패턴 장점은 향상된 기능을 깔끔하게 구현 가능.

즉 여러개의 객체를 조합하거나 작고 응집력 높은 인터페이스들을 조합하기만 하면 된다.

---

### - 어댑터 패턴

: 래퍼(wrapper)라고도 하는 이 패턴은 호환되지 않는 두 개 이상의 객체에 대한 인터페이스를 동시에 사용할 수 있게 한다.

개발을 하다보면 일반적으로 다형성을 가진 여러 클래스나 모델을 사용하게 된다.

새로운 객체를 직접 사용하는 대신 해당 객체를 수용할 수 있는 새로운 인터페이스를 개발할 수 있다.

- 구현 방법

1. 사용하려는 클래스를 상속 받는 클래스 만들기: 상속 받은 클래스는(필요시 파라미터나 서명 포함) search 메서드를 래핑하는 새로운 별칭의 메서드 갖는다. 상속을 통해 외부 클래스를 임포트하고 새로운 메서드를 갖는 클래스를 만든 다음 해당 메서드를 호출하는것
2. 


파이썬은 다중 상속을 지원하지만, 상속은 얼마나 많은 외부 라이버리를 가져올지 정확히 알기 어려워 강한 결합을 만들고 융통성을 떨어뜨린다. 개념적으로 상속은 is a 관계에 한정해서 적용하는 것이 바람직

타사 라이브러리를 정확히 이해하지 못한 채로 상속시 is a 관계인지 분명히 알수 없다.

따라서 나은 방법은 컴포지션을 사용하는 것이다. 객체에 인스턴스를 제공만 가능하다면 파라미터를 해당 인스턴스에 전달하기만 하면 된다.

---

### - 컴포지트(composite)

: 프로그램에서 사용하는 객체는 내부적으로 또 다른 여러 객체를 사용해서 작업하게 된다.

잘 정의된 로직을 가진 기본 객체도 있고, 이러한 기본 객체를 묶어서 사용하는 컨테이너 객체도 있다.

문제는 이러한 기본 객체와 컨테이너 객체를 특별한 구분 없이 동일하게 사용하길 원하는 경우에 발생한다.

객체는 구조화된 트리 형태로 볼 수 있따. 기본 객체는 리프 노드이고 컨테이너 객체는 중간노드라 볼 수 있다.

클라이언트는 이 중에 아무거나 호출하여 결과를 얻고자 할 것이다.

컴포지트객체도 클라이언트처럼 동작한다. 리프 노드인지 중간 노드인지에 상관없이 해당 요청을 관련 노드가 처리할 수 있을 떄까지 계속 전달한다.


---

### - 데코레이터

: 5장의 데코레이터 사용하여 코드 개선하기와 유사점은 이씾만 디자인 패턴에서 말하는 것과는 전혀 다른 개념

이 패턴을 사용하면 상속을 하지 않고도 객체의 기능을 동적으로 확장 가능

보다 유연한 객체를 만들려고 할 떄 다중 상속의 좋은 대안이 될수 있다.

기본적인 형태는 제공된 파라미터를 기반으로 생성자에게 사전을 만들고 그것을 그대로 변환하는것.

```
class DictQuery:
    def __init__(self, **kwargs):
        self._raw_query = kwargs

    def render(self) -> dict:
        return self._raw_query
```

데코레이터를 만들어 render 메서드에 적용 가능하지만 런타임에서 변경하려면 유연X

또한 일부만 취하거나 제외하련느 경우에도 문제 발생

=> 동일한 인터페이스를 가지고 여러 단계거쳐 결과를 향상 가능하며 결합도 할수 있는 객체 만드는 새로운 방법 필요

`데코레이션 단계`

이 객체들은 연결되어 있으며 각각의 본체는 본래 의도에 새로운 기능 추가 가능

파이썬의 경우 덕 타이핑 지원하기 떄문에 새로운 기본 클래스를 만들어서 캘르스 계층 구조에 새로 편입 시킬 필요 없음.

```
class QueryEnhancer:
    def __init__(self, query: DictQuery):
        self.decorated = query

    def render(self):
        return self.decorated = query

class RemoveEmpty(QueryEnhancer):
    def render(self):
        original = super().render()
        return {k: v for k, v in original.items() if v}

class CaseInsensitive(QueryEnhancer):
    def render(slef):
        original = super().render()
        return {k: v.lower() for k, v in original.items()}
```

QueryEnhancer를 상속받은 클래스들은 공통된 인터페이스를 가지고 있으므로 상호 교환가능.

이 객체는 데코레이팅된 객체를 수신하도록 설계

```
>>> original = DictQuery(key="value", empty="", none=None, upper="UPPERCASE", title="Title")
>>> newquery = CaseInsensitive(original)
>>> original.render()
{'key': 'value', 'empty':'', 'none':None, 'upper': 'UPPERCASE', 'title': 'Title'}
>>>
new_query.render()
{'key': 'value', 'upper': 'uppercase', 'title': 'title'}
```

파이썬의 동적인 특성을 활용해 다른 방버븡로 데코레이터 패턴을 구현할 수도 있다. 

각각의 데코레이션 단계를 함수로 정의한 다음 기본 데코레이터 객체(QueryEnhancer)에 전달할 수도 있다.

```
class QueryEnhancer:
    def __init__(
        self,
        query: DictQuery,
        *decorators: Iterable[Callable[[Dict[str, str]], Dict[str, str]]]
    ) -> None:
        self._decorated = query
        self._decorators = decorators

    def render(self):
        current_result = self._decorated.render()
        for deco in self._decorators:
            current_result = deco(current_result)
        return current_result
```

호솬성 위해 render() 메서드의 형태로 그래도 유지했기 떄문에 클라이언트는 코드를 수정하지 않아도 된다.

그러나 QueryEnhancer 사용방법은 다르다.

```
>>> query = DictQuery(key="bar", empty="", none=None, upper="UPPERCASE", title="Title")
>>> QueryEnhancer(query, remove_empry, case_insentive).render()
{{'key': 'bar', 'upper': 'uppercase', 'title': 'title'}}
```

디자인에 명시적으로 표현하기 위해 지식별로 클래스를 만들고 계층 구조를 구성하려는 경우에는 더욱 객체 지향적인 방식이 좋다.

---

### - 파사드(Facade)

: 객체 간 상호 작용을 단순화하려는 많은 상황에서 유용하다.

패턴은 여러 객체가 다대다 관계를 이루며 상호작용하는 경우에 사용된다.

각각의 객체에 대한 모든 연결을 마드는 대신 파사드 역할을 하는 중각 객체를 만드는 것이다.

파사드는 허브 또는 단일 차조점(single point of reference)의 역할을 한다. 새로운 객체가 다른 객체에 연결하려고 할 떄마다 연결해야 하는 N개의 객체에 대해 N개의 인터페이스를 만들어야 한다면 복잘할 것이다.

외부 오브젝트 입장에서는 파사드 내부의 모든 내용이 완전히 불투명해야한다.

이 패턴을 사용하면 객체의 결합력을 낮춰주는 확실한 장점 외에도 인터페이스의 개수를 줄이고 보다 나은 캡슐화를 지원할 수 있게 되므로 보다 간단한 디자인 유도하는 장점 있다.

이 패턴은 도메인 문제를 개선하기 위해서 뿐만 아니라 보다 나은 API 설계를 위해서도 사용할 수 있다.

이 패턴은 사용하여 단일 인터페이스를 제공하면 다일 진리점(single point of truth)또는 코드의 진입점(entry porint for code) 역학을 하여 사용자가 노출된 기능을 쉽게 사용할 수 있다.

뿐만 아니라 기능만 노출하고 나머지 모든 것은 인터페이스의 뒤에 숨김으로써 세부 코드는 원하는 만큼 리펙토링을 해도 된다.

왜냐하면 파사드 뒤에서 작업하는 한 자연스럽게 하위호환성이 유지될 것이며 사용자는 그 영향 받지 않는다.

파사드는 클래스나 객체에 한정된 것이 아니라 패키지에도 적용된다.

기술적으로 파이썬에서 패키지도 객체이지만 여기서는 모듈의 묶음을 말한다.

파사드의 아이디어는 패키지의 레이아웃을 결정하는데 사용할 수도 있다. 즉 사용자에게 노출해야 하는 임포트 가능한 외부용 레이아웃과 직접 임포트해서는 안 되는 내부용 레이아웃을 구분하는 것이다.

파이썬에서 디렉토리 패키지 빌드시 __init__.py 파일을 나머지 파일들과 함께 둔다. 이것이 모듈의 루트로서 파사드와 같은 역할을 한다.

나머지 파일들은 익스포트할 객체를 정의하지만 클라이언트가 직접 임포트해서는 안 된다.

init 파일이 파일을 임포트하고 클라이언트는 그곳에서 다시 임포트해야한다. 이것은 사용자에게 객체를 어디서 가져와야 할지 단일 진입점을 제공하는 것이므로 보다 나은 인터페이스라고 할 수 있다.

보다 중요한 것은 패키지를 구성하는 나머지 파일들을 마음껏 리펙토링하거나 재정렬할 수 있다는 점이다.

init파일의 API가 유지되는 한 클라이언트에 영향ㅇ르 주지 않게 된다. 이러한 것들이 바로 유지보수가 간으한 소프트웨어를 만들기 위해서 지켜야 하는 가장 중요한 원칙이다.

파이썬 자체에서 사용 중인 파사드  패턴의 예로 os 모듈이 있다. 이 모듈은 OS의 기능을 그룹화 하지만 그 아래에는 POSIX(Potable Operrating System Interface) OS용 posix모듈을 사용한다.(윈도우 플랫폼에서는 nt 라고함).

중요한 점은 이식성이 강해 posix 모듈을 직접 인포트하지 않아야 한다는 것이다. 대신 os 모듈을 임포트 한다.

왜냐하면 os 모듈이 어느 플랫폼에서 호출되었는지 확인하여 적절한 기능을 제공할 것이기 떄문인다.

---

### - 행동(behavioral)패턴

: 행동 패턴은 객체가 어떻게 협력해야하는지, 어떻게 통신해야하는지, 런타임 중에 인터페이스는 어떤 형태여야 하는지에 대한 문제를 해결하는 것을 목표로 한다.

1. 책임 연쇄 패턴(chain of reposibbility)
2. 템플릿 메서드 패턴
3. 커맨드 패턴
4. 상태패턴

이러한 문제는 정적으로 상속을 통해, 동적으로는 컴포지션을 통해 해결될 수 있다.

예제에서 어떤 패턴을 사용하든지 간에 결국에는 중복을 피하거나 행동을 캡슐화하는 추상화를 통해 모델 간의 결합력을 낮춤으로써 훨씬 좋은 코드를 만들게 된다는 점을 알 수 있다.

---

### - 책임 연쇄 패턴

: 후계자(succcessor)라는 개념이 추가, 이 후계자는 현재 이벤트가 로그 라인을 처리할 수 없는 경우에 대비한 다음 이벤트 객체

이벤트를 연결하고 각 이벤트는 데이터를 처리하려고 시도한다. 직접 처리가 가능한 경우 결과를 반환하고, 처리가 불가능하면 후계자에게 전달하는 이러한 과정을 반복한다.

```
import re

calss Event:
    pattern = None

    def __init__(self, next_event=NOne):
        self.successor = next_evnet

    def process(self, logline: str):
        if self.can_process(logline):
            return self._process(logline)

        if self.successor is not None:
            return self.successor.process(logline)
    
    def _process(self, logline: str) -> dict:
        parsed_data = self._arse_data(logline)
        return {
            "type": self.__class__.__name__,
            "id": parsed_data["id"],
            "value": parsed_data["value"]
        }

    @classmethod
    def can_process(cls, logline: str) -> bool:
        return cls.pattern.match(logline) is not None

    @classmethod
    def _parse_data(cls, logline: str) ->dict:
        return cls.pattern.match(logline).groupdict()

class LoginEvnet(Evnet):
    pattern = re.compile(r"(?P<id>\d+): \s+login\s+(?P<value>\S+)")

class LogoutEvent(Event):
    pattern = re.compile(r"(?P<id>\d+): \s+login\s+(?P<value>\S+)")
```

이젠 event 객체들을 만들고 처리해야 할 특정 순서로 정렬하면 된다. 이벤트 객체들은 모두 process() 메서드를 가지고 있고 메세지에 대한 다형성을 가지고 있으므로 정렬 순서는 클라이언트가 마음대로 바꿀 수 있다.

뿐만 아니라 객체마다 동일한 논리의 process() 메서드를 가지고 있다. 즉, 제공된 데이터에서 정보를 출하여 처리하려고 시도하고, 처리할 수 없다면 다음 이벤트에 전달하여 처리가 가능한지 확인 가능하다.

```
>>> chain = LogoutEvent(LoginEvent())
>>> chain.process("567: login User")
{'type': 'LoginEvnet', 'id': '567', 'value': 'User'}
```

LogoutEvent가 LoginEvent를 후계자로 받는 방법과 처리할 수 없는 것을 요청했을 때 어떻게 다른 객체로 전달하는지에 주의하자. 결과 사전에 있는 type에서 볼 수 있듯이 사전은 LoginEvent가 생성한 것이다.

이 솔루션은 충분히 유연하며 모든 조건들이 상호 배타적이라는 특성을 그재로 유지하고 있다.

판별 로직의 충돌이 없고 동일한 데이터를 하나 이상의 핸들러가 처리하지 않는다면 어떤 순서로 이벤트를 처리하는지는 상관 없다.

그러나 만약 이러한 가정을 할 수 없다면 어떠헥 될까? __subclassess__() 호출로 이벤트 목록을 구했었는데 직접 입네트 리스트를 만들어서 처리하면 우선순위를 조절 가능하다.

여기까지는 이것으로 충분한다. 그런데 사용자가 런타임 중에 우선순윙를 변경하고 싶으면 어떻게 해야할까?

이것은 단점이 될 수 있다. 새로운 솔루션을 사용하면 이러한 추가 요구사항도 만족시킬 수 있다. 왜냐하면 런타임 중에 책임을 연결(chain)하면 되기 떄문이다.

<br>

ex) 예를 들어 로그인과 로그아웃 이벤트를 둘 다 처리할 수 있는 타입 추가

```
class SessionEvent(Evnet):
    patter = re.compile(r"(?P<id>\d+): \s+login\s+(?P<value>\S+)"))
```
어떤 이유로 애플리케이션에서 LoginEvent 전에 SessionEvent를 먼저 처리하고 싶은 경우는 다음과 같이 하면 된다.

```
chain = SessionEvent(LoginEvent(LogoutEvent()))
```

순서를 변경하여 세션 이벤트가 로그인 이벤트보다 우선순위가 높으며, 로그인 이벤트는 로그아웃 이벤트보다 우선순위가 높다는 것을 선언한 것이다.

클래스의 meets_condition() 메서드에 의존하는 것보다는 이렇게 여러 객체에 패턴을 적용하는 것이 후러씬 유연하다는 것을 알 수 있다. 파이썬에서는 클래스 자체가 객체이지만 그것마능로는 이번 문제에서 발생하는 경직성을 피할 수 없었다.

---

### - 템플릿 메서드 패턴

: 템플릿 메서드 패턴(template method pattern)을 적절히 구현하면 중요한 이점을 얻을 수 있다. 

코드의 재사용성을 높여주고 객체를 보다 유연하게 하여 다형성을 유지하면서도 코드를 쉽게 수정할 수 있다.

주요 개념은 어떤 행위를 정의할 떄 특정한 형태의 클래스 계층구조를 만드는 것이다.

public 인터페이스에서 중요한 역할을 하는 메서드를 예로 보면 계층구조를 이루는 모든 캐르스 들은 공통된 템플릿을 공유하며 템플릿의 특정요소만 변경할 수도 있다.

그런 다음 공통적인 로직을 부모 클래스의 public 메서드로 구현하고 그 안에서 내부의 다른 private 메서드들을 호출하는 것이다.

이렇게 템플릿에서 호출하는 다른 내부의 메서드들은 파생 클래스에서 수정될 수 있지만 템플릿에 이쓴ㄴ 기본 공통 로직은 모두 재사용된다.

위의  책임 연쇄 패턴에서 구현한것도 템플릿 메서드 패턴 이다.

Event에서 파생된 클래스는 오직 특정 패턴 하나만 구현한 점 주의요망

나머지 공통적인 논리는 Event 클래스의 템플릿 메서드에 있다.

process 이벤트는 공통적인 로직을 가지고 있으며 can_process() 와 _process()라는 두 개의 보조 메서드가 있따.

_process() 메서드는 다시 _parse_data() 메서드를 호출한다.

이러한 추가 메서드들은 클래스 속성에 의존한다. 따라서 새로운 타입에서 기능을 확장하려면 단지 파생클래스에서 정규식으로 속성ㅇ르 재정의하기만 하면 된다.

이렇게만 하면 나머지 로직은 템플릿 메서드에 따라서 재정의된다.

로그 라인을 처리하는 로직은 오직 부모클래스에서 단 한번만 정의하였으므로 코드의 재사용성도 매우 높다.

이 패턴을 사용하면 다형성을 쉽게 보존 가능하여 디자인이 유연해진다.

만약 어떤 이벤트 타입에서 파싱 방법을 변경해야 한다고 하면 하위 클래스의 private 메서드를 오버라이드 하기만 하면 된다.

여기서 반환 값의 타입이 동일하다면 하위 호환성 또한 유지될 것이다.

파생 클래스의 메서드를 호출하는 것은 부모 클래스에 있는 템플릿 메서드 이므로 자연스럽게 리스코프 치환 원칙과 개방/폐쇄 원칙 준수할 수 있다.

이 패턴은 자신만의 라이버리나 프레임워크를 만들 때에도 유용하다. 이런 방법으로 로직을 정리하면 사용자에게 클래스의 일부 행동을 쉽게 수정하도록 할 수 있따.

즉, 사용자는 하위 클래스를 만들고 특정 private 메서드를 오버라이드하기만 하면 하위 호환성이 유지되는 새로운 행동을 정의할 수 있다.

---

### - 커맨드

커맨드 패턴(commnad pattern)은 수행해야 할 작업을 요청한 순간부터 실제 실행 시까지 분리할 수 있는 기능 제공

또한 클라이언트가 발행한 원래 요청을 수신자와 분리도 가능하다. 수신자는다른 객체일 수도 있다.

__call__() 매직 메섣르르 구현하여 호출 가능한 객체를 생성할 수 있다.

따라서 일단 객체를 초기화하고 나중에 호출을 할 수 있다.

주요 개념은 커맨드도 정의 이후에 수정할 수 있따는 것이다. 즉, 클라이언트가 실행할 명령을 지정한 다음 누군가 최종적으로 수행하기로 결심할 떄까지는 일부 파라미터를 변경하거나 옵션을 추가할 수 있음을 의미한다.

위의 구조를 따르도록 하는 가장 간단한 방법은 실행될 명령의 파라미터들을 저장하는 객체(command)를 만드는 것이다.

그리고 명령에 필요한 파라미터에서 필터를 더하거나 제거하는 것처럼 상호 작용할 수 있는 메서드를 제공하는 개체(invoker)를 만들어야 한다.

선택적으로 invoke 객체에 요청을 감시하기 위한 로그를 추가 할 수도 있다.

마지막으로 실제로 작업을 수행 할 객체(receiver)를 만들어야 한다.

실제 작업을 하는 메서드는 단순히 __call__() 메서드를 사용할 수도 있고 사용자 정의 메서드를 사용할 수도 있다.

그리고 클라이언트 객체(client)에서(invoker에게 최종요청을 하는) do() 메서드를 호출한다.

---

### - 상태 패턴

: 상태(state) 패턴은 구체화(reification)를 도와주는 대표적인 소프트웨어 디자인 패턴

패턴을 사용하면 도메인 문제의 개념을 부수적인 가치에서 명시적인 객체로 전환가능

8장에서 머지 리퀘스트(MR)를 나타내는 객체가 있었는데 객체는 내부적으로 상태(open, close 등)을 가지고 있다. 그리고 해당 상태들은 그저 특정 상태를 나타내는 문자열이었으므로 열거형을 사용해 표현했었다.

그런데 만약 어떤 행동을 해야 하거나, 전체 머지 리퀘스트에 대해서는 상태와 전이에 따라 다른 행동을 수행해야만 한다면 이런 디자인으로는 충분하지 않을 것이다.

행동, 즉 런타임 구조를 코드에 추가한다는 사실은 객체의 관점에서 다시 생각해보게 만드는 일이다.

왜냐하면 행동을 추가하는 일은 결국 객체가 할 일이기 때문이다. 여기세어 구체화가 필요하다. 

이제 상태는 단순히 문자열의 열거형이 될 수 없고 객체가 되어야 한다.

<br>

머지 리퀘스트와 관련해 다음 규칙 추가했다고 가정

open 상태에서 closed 상태로 갈 떄는 다음에 다시 리뷰를 시작할 것이므로 모든 승인이 제거된다.

머지 리퀘스트가 방금 open된 상태라면 승인 개수는 reopen인지에 상관없이 0개가 된다.

그리고 머지 리퀘스트가 머지될 떄는 소스 브랜치를 삭제한다. 물론 cloesed 상태의 머지 리퀘스트를 머지하는 등의 잘 못된 전이는 불가능한다.

<br>

모든 논리를 단일 장소, 즉 MergeRequest 클래스에 넣으면 하나의 클래스가 너무 많은 책임을 갖게 되므로 좋은 디자인 X

그리고 많은 메서드와 많은 수의 if문이 있는 클래스가 될 것이다. 또한 어떤 코드가 어떤 비지니스 로직을 나타내는지 구별하기 어려울 것이다.

따라서 상태별로 작은 객체를 만들어 각각의 객체가 적은 책임을 갖게 하는 것이 좋다.

먼저 표현하고자 하는 각 종류의 상태를 개체로 만들고, 각 객체의 메서드에 앞서 설명한 규칙에 따라 전이 로직을 작성한다.

MergerRequest 객체는 상태를 저장하는 _state 속성을 가지며 결국 해당 속성을 통해 최종 MergeRequest 상태를 알 수 있다.

MergeRequst에서 상태 전이를 하려면 더블 디스패치(double-dispatching) 메커니즘 필요

```
class InvalidTransitionError(Exception):
    """도달 불가능한 상태에서 전이시 발생하는 예외"""

class MergeRequestState(abc.ABC):
    def __init__(self, merge_request):
        self._merge_request = merge_request

    @abc.abstracmethod
    def open(self):
        ...

    @abc.abstracmethod
    def merge(self):
        ...

    def __str__(self):
        return self.__class__.__name__

class Open(MergeRequestState):
    def open(self):
        self._merge_request.approvals = 0

    def close(self):
        self._merge_request.approvals = 0
        self._merge_request.state = Closed

    def merge(self):
        logger.info(%s 머지", self._merge_request)
        logger.info("%s 브랜치 삭제", self._merge_request.source_branch)
        self._merge_request.state = Merged

class Closed(MergeRequestState):
    def open(slef):
        logger.info("종료된 머지 리퀘스트 %s 재오픈", self._merge_request)
        self._merge_requst.state = Open

    def close(self):
        pass

    def merge(self):
        raise InvalidTransitionError("종료된 요청을 머지 할수 없음")

class Merged(MergeRequestState):
    def open(self):
        raise invalidTrasitionError("이미 머지 완료")
    
    def close(self):
        raise invalidTrasitionError("이미 머지 완료")

    def merge(self):
        pass

class MergeRequest:
    def __init__(self, source_branch: str, target_branch: str) -> None:
        self.source_branch = source_branch
        self.targert_branch = target_branch
        self._state = None
        self.approvals = 0
        self.state = Open

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, new_state_cls):
        self._satte = new_state_cls(self)

    def open(self):
        reutnr self.state.open()

    def close(self):
        reutnr self.state.close()

    def merge(self):
        reutnr self.state.merge()

    def __str__()    :
        reutnr f"self.target_brach:self.source_branch"
```


1. state는 프로터티로 public, 머지 리퀘스트에 대한 상태를 생성하는 방법을 정의한 단일 위치. 파라미터로 self 전달
2. 추상 기본 클래스는 꼭 필요한 것은 아니지만 이것을 사용하는 몇 가지 이점 있음.

2.1 다루는 대상의 종류를 더 명확하게 한다.
2.2 모든 하위 상태 객체가 인터페이스의 모든 메서드를 구현하도록 강제한다.

모든 메서드를 구현하는 것의 대안으로 두가지 방법 있음

2.2.1 필요 없는 메서드를 구현하지 않고 유효하지 않은 액션을 하려고 하면 AttributeError 발생시키는 방법, 그러나 이는 정확한 표현 아니고 사용자능 어떤 일 발생했는지 알수 없음
2.2.2 추상 클래스가 아닌 간단한 일반 클래스를 사용하여 관련 메서드를 비워두는 것. 물론 아무것도 하지 않는 것만으로 어떤 일을 해야 하는지가 명확해지는 것은 아니다.
그러나 머지가 완료된 상태에서 머지 요청을 하는 것처럼 파생 클래스에서 아무것도 하지 않아야 되느누 경우가 있따면 모든 객체에 일일이 구현하는 대신에 아무것도 구현하지 않을 수 있다.

3. MergerRequest와 mergeRequestSate는 서로 연결되어 있다. 상태 전이가 되면 이전 객체는 더 이상 참조될 필요가 없으므로 가비지 컬렉션의 대상이 되어야 하므로 이 관계는 항상 1:1 이어야 한다.
1:1 관계가 어렵다면 약한 참조(weak reference)를 사용 할수 있다.

<br>
<br>

객체를 어떻게 사용하는지 예시

```
>>> mr = MergeRequest("devleop", "master")
>>> mr.open()
>>> mr,.approvals
0
>>> mr.approvlas = 3
>>> mr.close()
>>> mr.approvals
0
>>> mr.open()
INFO; log: 종료된 머지 리퀘스트 mster:develop 재오픈
>>> mre.merge()
INFO:log:master:develop 머지
INFO:log: develop tkrwp
>>> mr.close()
Traceback (most recent call last):
...
InvalidTransitionError: 이미 머지 완료
```

상태 전이는 state 객체에 위임되며 state는 항상 MergeRequest를 가리키게 딘다.

satte가리키는 객체는 ABC의 하위 클래스 중 하나이다. 이들은 모두 동일한 메세지에 대해서 적절한 처리(브랜치 삭제, 예외 발생 등)를 한 다음 MergeRequest를 다음 상태로 전이

MergerRequest가 모든 처리를 state 객체에 위임했기 떄문에 항상 self.sate.open()과 같은 형태로 호출되게 된다. 이 같은 반족적인 코드는 __getattr__() 매직 메서드를 사용하면 반복 코드 제거 가능

```
class MergeRequest:
    def __init__(self, source_branch: str, target_branch: str) -> None:
        self.source_branch = source_branch
        self.targert_branch = target_branch
        self._state = None
        self.approvals = 0
        self.state = Open

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, new_state_cls):
        self._satte = new_state_cls(self)

    @property
    def status(self):
        reutnr str(self.state)

    def __getattr__(self, method):
        reutrn getattr(self.state, method)

    def __str__()    :
        reutnr f"self.target_brach:self.source_branch"
```

일부 코드는 재사용하고 반복되는 코드는 제고, 이렇게 하면 추상 기본 클래스가 더 의미 있는 선택이 된다.

문서화된 모든 액션을 어떤 단일 장소에 옮기고 싶다고 해보자.

이전에는 그장소가 MergeRequest 클래스 였지만 이제는 그러한 단순 반복적인 기능만 하던 메서드가 사라지고 단일 진리점으로 MergeRequestState만 사용 된다.

특히 _state 속성의 타입 애노테이션은 사용자가 어디에서 인터페이스의 정의를 찾을 수 있는지 알려주는데 도움이 된다.

사용자는 MergeRequest가 가지고 있지 않은 모든 것을 state 속성이 가지고 있다는 것을 알 수 있다.

init 메서드에서 _state의 타입 어노테이션은 _state가 MergeRequestState 타입의 객체임을 알려주고 있다.

따라서 MergeRequestState을 살펴보게 되며 open(), close()와 merge() 메서드를 안전하게 사용할 수 있음을 알 수 있게 된다.

---

### - Null 객체 패턴

: 원칙, 함수나 메서드는 일관된 타입이 반환해야 한다

이것이 보장된다면 클라이언트는 다형성을 가진 메서드에서 반환되는 객체에 대해 null 체크를 하지 않고도 바로 사용 가능

경우에 따라서 해당 디자인 패턴이 완전히 사라지는 경우도 있었고 구현하기가 쉬운 경우도 있었다.

원래 디자인 패턴의 주요 목표는 메서드나 함수가 작동하는데 필요한 구체적인 클래스를 명시하지 않는 것이다.

이러한 이유로 인터페이스르 새로 만들고, 기존의 객체들을 재배치하여 이러한 인터페이스에 적합하게 만드는 작업을 하는 것이다.

하지만 파이썬에서는 대부분의 경우 이러한 작업이 필요하지 않으며, 필요한 메서드를 갖추기만 한다면 다른 객체를 그냥 전달해도 잘 작동한다.

반면에 객체가 반드시 인터페이스를 준수할 필요가 없다는 사실은 메서드의 반환 값에 대해서는 더 주의를 요한다는 것을 의미한다.

함수가 전달된 파라미터에 대해 가정을 하지 않는 것처럼 클라이언트도 반환 값에 대해 가정하지 않는 것이 공정하다.

호환 가능한 객체를 제공하는 것은 해당 함수의 책임이다. 이는 계약에 의한 설계르르 통한 강제하거나 검증할 수 있다.

이전 섹션에서 살펴본 책임 연쇄 패턴을 보면, 이 패턴은 작은 객체들을 사용해 책임을 분리함으로써 유연함과 함께 많은 장점을 가져다 주었다.

그러나 문제점 중 하나는 메세지를 처리한 뒤 반환하는 객체가 무엇인지 알 수 없다는 것이다. 특히 로그라인을 처리할 적절한 객체가 없으면 메서드에서 None을 반환한다.

사용자가 통과한 데이터를 어떻게 처리할 지는 모르지만, 사용자는 일단 사전 타입의 반환 값을 기대한다. 따라서 아무 처리를 하지 않으면 오류가 발생한다.

```
AttrributeError: 'None Type' object has no attrivute 'keys'
```

이 경우 수정 방법은 간단한다. process() 메서드의 기본 값을 None이 아닌 빈 사전으로 하면된다.

일관성 있는 타입의 객체를 반환하도록 하자. 그러나 메서드가 사전 형태가 아닌 도메인에서 사용 중인 사용자 정의 객체를 반환하다면 어떻게 될까?

이 문제를 해결하려면 비어 있는 상태의 객체를 만들고 해당 상태 객체를 반화하면 된다.

어떤 시스템에 사용자를 나타내는 객체가 있다고 해보자. 사용자 ID로 조회하는 함수가 있는데 검색된 사용자가 없을 때는 다음 두 가지중 하나를 해야한다.

1. 예외발생
2. userUnknown 타입을 반환

그러나 어떠한 경우에도 None을 반환하면 안 된다. None이라는 문구는 방금 일어난 일에 대 아무것도 설명해주지 않으며 호출자는 특별한 공지가 없으면 아무 생각 없이 반환 객체에 대해 메서드를 호출할것이다.

그럼 결국 AttrivuteError가 발생한다.

UserUnknown 객체처럼 비어있는 상태의 객체를 나타내는 null 객체는 사용자가 원래 기대하던 것과 동일한 메서드를 가지고 있어야하며 아무 일도 수행하지 않아야 한다.

이 구조를 사용하면 런타임 시 오류 피할 수 있을 뿐만 아니라 객체를 유용하게 활용할 수도 있따.

코드 테스트하기 쉬워지며, 디버깅에 도움이 될 수도 있다.

파이썬의 매직 메서드를 잘 활용하면 호출되는 방버벵 관계없이 아무 것도 하지 않지만 거의 모든 모든클라잉너테에서 호출할 수 있는 일반적인 null 객체를 생성할 수도 있디.

이러한 객체는 Mock 객체와 비슷하다. 그러나 이렇게 까지 일반화 하는것은 좋지 않다.

그 이유는

1. 도메인의 특성을 나타내는 의미가 없어진다. 이 예제에서는 UnknownUser 타입을 사용함으로써 호출자에게 쿼리에 문제가 발생했음을 명확하게 알릴 수 있었지만 일반적인 타입을 사용하면 의미를 정확히 알 수 없다.
2. 원래의 인터페이스를 따르지 않게 되는 문제가 생긴다. UnknownUser도 사용자이므로 동일한 메서드를 가져야한다는 것이다. 호출자가 실수로 없는 메서드를 요청하면 AttributeError 예외가 발생하는 것이 좋아 보인다. 무엇이든 할 수 있고 어떤 것에도 반응하는 일반적인 null객체를 사용하면 이러한 정보를 잃어버리는 셈이고 버그가 발생할 수도 있다. spec=User와 같이 Mock 객체를 만들면 예외가 발생하지만 mock 객체를 사용하여 비어 있는 상태를 나타내는 것은 도메인의 특성을 나타내려는 의도를 해치게 된다.