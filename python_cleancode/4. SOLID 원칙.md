- S: 단일 책임 원칙
- O: 개방/폐쇄의 원칙
- L: 리스코프(Liskov) 치환 원칙
- I: 인터페이스 분릭 원칙
- D: 의존석 연전 원칙

---

### 단일 책임 원칙
: 단일 책임 원칙(Single Responsibility Principle _SRP) 소프트웨어 컴포넌트(일반적을 클래스)가 단 하나의 책임을 가져야 한다는 원칙.

=> 하나의 구체적인 일을 담당한다. 따라서 변화해야할 이유는 단 하나 여야한다.

이 디자인 원칙은 응집력 있는 추상화를 하는데 도움이 된다.

종종 너무 많은 것을 알고 있는 객체를 일컬어 신(god) 객체 라고 부른다.  이러한 객체는 행동을 구룹화 한것이므로 유지보수 어렵다.

=> 클래스는 작을수록 좋다.

클래스의 메서드는 상호 배타적이며 서로 관련 없어야 하고, 이들은 서로 다른 책임을 가지고 있어 더 작은 클래스로 분해할 수 있어야 한다.

```
SRP를 준수하지 않은 디자인

class SystemMonitor:

    def load_activity(self):
        """소스에서 처리할 이벤트 가져오기"""

    def identify_eevent(self):
        """가져온 데이터 파싱하여 도메인 객체 인벤트로 변환"""

    def stream_event(self):
        """ 파싱한 이벤트를 외부 에이전트로 전송"""
```

위의 주요 문제점<br>
: 독립적인 동작을 하는 메서드를 하나의 인터페이스에 정의함.

로더는 자체적인 절차를 갖게 될것이며, 데이터 소스연결, 데이터 로드, 예상된 형식 파싱 등의 작업이 있을것이다.

이 중에 어던 것이라도 수정해야 한다면 SystemMonitor 클래스를 변경해야 한다. `데이터 표현이 변경되었다고 해서 시스템 모니터링 객체를 변경해서는 안된다.`

<br>

- 책임 분산
: 관리 쉽게 하기 위해 모든 메서드를 다른 클래스로 분리하여 각 클래스마다 단일 책임 갖게 한다.

각각의 객체들은 특정한 기능을 캡슐화 화여 나머지 객체들에 영향을 미치지 않으며 명확하고 구체적인 의미 갖게 만든다.


---

### 개방/폐쇄 원칙(OCP)
: 개방/폐쇄 원칙(Open/Cloase Principle)은 모듈이 개방되어 있으면서도 폐쇄되어야 한다는 원칙.

로직을 캡슐화 하여 확장에는 개방, 수정에는 폐쇄되도록 해야한다. 즉 새로운 분제 발생시 새로운 것을 추가만 할뿐 기존코드는 그대로 유지해야 한다.

개방/폐쇄 원칙을 따르는 디자인을 달성하려면 추상화를 해야하며, SystemMonitor 클래스를 예시로 하면, SystemMonitor 클래스를 추상적인 이벤트와 협력하도록 변경하고, 이벤트에 대응하는 개별 로직은 각 이벤트 클래스 위임

그런 다음 각각의 이벤트에 다형성을 가진 새로운 메서드를 추가.

```
class Event:
    def __init__(self, raw_data):
        self.raw_data = raw_data

    @staticmethod
    def meets_condition(event_data: datic):
        return False:

class UnknownEvent(Event):
    """데이터만으로 식별할 수 없는 이벤트"""

class LoginEvent(Event):
    @staticmethod
    def meets_condition(event_data: dict):
        return(
            event_data["before"]["session"] == 0
            and event_data["after"]["sesstion"] == 1
        )
    
class LogoutEvent(event):
    @staticmethod
    def meets_condition(event_data: dict):
        return(
            event_data["before"]["session"] == 0
            and event_data["after"]["sesstion"] == 1
        )

...

class LogoutEvent(Event):
...


class SystemMonitor:
    ""시스템에서 발생한 이벤트 분류"""

    def __init__(self, event_data):
        self.event_data = event_data

    def identify_event(self):
        ...
```

새 이벤트 추가시에도 SystemMonior.identify_event() 메서드는 수정 필요 없음. 따라서 이 메서드가 새로운 유형의 이벤트에 대해서 폐쇄되어 있다고 말할 수 있다.

반대로 Event 클래스에는 필요할 떄마다 새로운 유형 이벤트 추가 가능. 따라서 새로운 타입의 확장에 대해 개방되어 있다고 말할 수 있다.

OCP 원칙은 다형성과 밀접하게 관련되어있다. 이것은 소프트웨어 엔지니어링에서 유지보수성에 대한 문제를 해결한다.


---

### 리스코프 치환 원칙(LSP)
: 리스코프 치환 원칙(Liskov substitution principle, LSP)은 설계 시 안정성을 유지하기 위해 객체 타입이 유지해야하는 일련의 특성을 말한다.

```
어떤 클래스에서든 클라리언트는 특별한 주의를 기울이지 않고도 하위 타입을 사용할 수 있어야 한다.
```

어떤 하위 타입 사용해도 결과 염려 하지 않아야 한다. 즉 클라이언트는 완전히 분리되어 있는 클래스 변경 사항과 독립되어야 한다.

LSP 규칙에 따르면 하위 클래슨느 상위 클래스에서 정의한 계약을 따르도록 디자인 해야한다.

LSP는 Mypy 나 Pylint 같은 도구를 사용해 쉽게 검출 가능.

```
class Event:
    ...
    def meets_condition(self, event_data: dict) -> bool:
        return False

class LoginEvent(Evnet):
    def meets_condition(self, event_data: list) -> bool:
        retrun bool(event_data)
```

Mypy 실행시

error: Argument 1 of "meets_condition" incompatible with supertype "Event" 발생

파생 클래스가 부모 클레스에서 정의한 파라미터와 다른 타입 사용했기 떄문에 다르게 동작한다.

반환값을 bool 값이 아닌걸로 변경해도 오류 발생한다.

LSP 원리가 결국 새로운 클래스가 원래의 계약과 호환되지 않는 확장을 하렬고 하면 클라이언트와 계약이 깨져서 결과적으로 확장이 불가능해진다.

또는 확장을 하게 하려면 수정에 대해 폐쇄되어야 한다는 원칙을 깨야한다.

LSP에서 제안하는 방식으로 신중하게 클래스를 디자인하면 계층을 올바르게 확장하는데 도움이 된다. 즉 LSP 가 OCP에 기여한다고 말할 수 있다.


---

### 인터페이스 분리 원칙
: 인터페이스 분리 원칙(Interface Segregation Principle, ISP) 작은 인터페이스에 대한 가이드 라인 제공

```
객체 지향적인 용어로 인터페이스란? 객체가 노출하는 메서드의 집합.
```

즉, 객체가 수신하거나 해석 가능한 모든 메시지가 인터페이스를 구성, 이것들은 다른 클라이언트에서 호출 할 수 있는 요청

인터페이스는 클래스에노출된 동작의 정의와 구현을 분리한다.

파이썬에서는 인터페이스는 클래스 메서드의 형태를 보고 암시적으로 정의된다. 이유는 `덕 타이핑(duck typing)` 원리를 따르기 때문이다.

```
덕 타이핑 이란? 모든 객체가 자신이 가지고 있는 메서드와 자신이 할수 있는 일에 의해서 표현된다는 점에서 출발한다.
```

즉 클래스의 유형, 이름, docstring, 클래승 속성 또는 인스턴스 속성에 관계없이 객체의 본질을 정의하는 것은 궁극적으로 메서드의 형태이다.

클래스의 메서드는 실제로 그 객체가 무엇인지 결정

\# 새가 오리처럼 걷고 오리처럼 꽤꽥 소리를 낸다면 오리여야만 한다는 데서 `덕 타이핑` 이라고 불림

파이썬은 오랫동안 인터페이스를 정의하는 방법으로 덕 타이핑 사용.

파이썬3에서 추상 기본 클래스 개념을 도입 했다.

```
추상 기본 클래스는 파생 클래스가 구현해야 할 일부분을 기본 동작 또는 인터페이스로 정의하는 것
```

이는 특정 중요 메서드 실제로 재정의 되었는지 확인 필요시 유용하며, ininstance()와 같은 메서드의 기능을 재정의 하거나 확장하는 메커니즘으로도 작동

ISO의 뜻은 결국 다중 메서드를 가진 인터페이스가 있다면 매우 정확하고 구체적인 구분에 따라 더 작은 수의 메서드(가급적 한개)를 가진 여러 개의 메서드로 분할하는 것이 좋다.

<br>
--- 

### - 인터페이스는 작을수록 좋다.

추상 클래스든 아니든 기본 클래스는 다른 클래스들이 확장할 수 있또록 인터페이스를 정의한다.

응집력 관점에서 가능한 단 한가지 일을 수행하는 작은 인터페이스여야한다. 그렇다고 반드시 한 가지 메서드만 있어야 한다는 뜻은 아니다.

하나 이상의 메서드라도 적절하게 하나의 클래스에 속해 있을수 있다.

ex) 컨텍스트 관리자는 __error__ 와 __exit__ 두가지 메서드 필요로 한다. 이들은 반드시 함께 제공되지 않으면 유효한 컨텍스트 관리자가 아님.

---

### 의존성 역전
: 의존성 역전 원칙(DIP)은 코드가 깨지거나 손상되는 취약점으로부터 보호해주는 흥미로운 디자인 원칙을 제시한다.

의존성을 역전시킨다는 것은 코드가 세부 사항이나 구체적인 구현에 적응하도록 하지 않고, 대신에 API 같 것에 적응하도록 하는것.

추상화는 인터페이스 형태로 제공됨. 파이썬에서는 추상 기본 클래스의 형태로 제공됨.

일반적으로 구체적인 구현이 추상 컴포넌트보다 훨씬 자주 변경됨. 이런 이유로 시스템이 변경, 수정 또는 확장될 것으로 예상되는 지점에 유연성 확보 위하여

추상화(인터페이스)를 사용하는것.
