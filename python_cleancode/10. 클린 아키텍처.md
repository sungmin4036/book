### - 관심사의 분리

: 애플리케이션 내부에는 여러 컴포넌트 있다. 

컴포넌트 코드는 모듈이나 패키지와 같은 하위 컴포넌트로 나뉜다

모듈은 클래스나 함수

클래스는 다시 메서드로 나눌 수 있다.

이 책에서는 이러한 컴포넌트를 가능한 작게 유지하는 데 중점을 둠. 특히 함수는 한 가지 작업만 수행해야하며 작게 유지해야 한다.

이렇게 한 이유는 이렇게 제시 되었다.

1. 작은 함수는 이해하기 쉽고 따라가기 쉬우며 디버그 하지 쉽다.
2. 테스트하기 쉽다. 코드 조각이 작을수록 단위 테스트를 작성하는 것도 쉬움

애플리케이션의 컴포넌트는 높은 응집력과 낮은 결합력을 가져야 한다.

컴포넌트를 작은 유닛으로 나누어 각 컴포넌트를 단 하나의 잘 정의도니 책임을 갖게 하고 수정이 쉽도록 하면 보다 나은 구조 얻을 수 있었다.

새로운 요구사항 생기면 단 하나의 장소에서만 수정해야 하고 나머지 코드는 영향을 받지 않아야 한다.

코드에서 말하는 컴포넌트는 이러한 응집력이 높은 유닛을 말한다.( ex 클래스)

아키텍처에서 말하는 컴포넌트는 시스템에서 작업 단위로 췹글할 수 있는 모든 것을 말한다.

컴포넌트는 자신만의 주기를 가지고 배포되어야 하며, 나머지 시스템의 컴포넌트와 독립적이어야 한다. 엄밀히 말하면 시스템 즉, 전체 애플리케이션의 일부이다.

파이썬 프로젝트의 경우 컴포넌트는 패키지가 될 수 있지만 서비스가 될 수도 있다.

서로 다른 수준의 세분화를 한 두 개의 개념을 동일한 기준에서 어떻게 바라봐야 하는지 유의해야 한다.

<br>


이전 장에서 사용한 이벤트 시스템은 컴포넌트로 간주될 수 있다.

이는 명확하게 로그에서 확인된 이벤트를 처리하는 목적을 가진 작업 단위이며, 파이썬 패키지 또는 서비스의 형태로 나머지와 독립적으로 배포 가능하며, 시스템의 일부분이지만 전체 애플리케이션 자체는 아니기 때문이다.

<br>

좋은 디자인이란 잘 정의된 하나의 책임을 가지고, 독립적으로 분리된, 유지보수가 쉬운 디자인을 말한다.

이러한 특징들은 함수, 클래스, 메서드와 같은 세부사항에 적용될 뿐만 아니라 소프트웨어 아키텍처의 컴포넌트에도 동일하게 적용할 수 있다.

<br>
<br>

대형 시스템을 하나의 컴포넌트로 구현하는 것은 바람직X.

모노리식(monolithic) 단일 애플리케이션은 단일 진실의 근원(single source of truth)처럼 동작하여 시스템의 모든 것을 책임지고 의도하지 않은 결과를 유발할 수 있다.

모노리식 단일 애플리케이션은 분리 어렵고, 변경된 부분 식별 어렵고, 효과적으로 테스트하기 어렵다.

코드의 모든 것을 한 곳에 두면 관리하기 어렵게 되는 것처럼, 컴포넌트도 모든 것을 한 곳에 두면 문제가 생기게 된다.

응집력 있는 시스템 컴포넌트를 만드는것은 추상화의 수준에 따라 다양하게 구현 가능.

1. 여러 번 재사용될 만한 공통 로직을 파이썬 패키지에 두는것
2. 마이크로 서비스 아키텍처를 사용하여 애플리케이션을 여러 개의 작은 서비스로 나누는 것
3. ...


---

### - 추상화

: 시스템 도메인 문제에 관해서 추상화란 세부 구현 사항을 최대한 숨기는것.

코드는 그 자체로 문서화 되는 정도의 표현력을 가져야 하며, 문제의 본질에 대한 해결책을 제시하는 올바른 추상화를 해야 한다.

아키텍처도 마찬가지로 그 자체로 시스템이 어떻게 되는지 설명할 수 있어야 한다.

중요한 것은 시스템이 무엇을 하는가이다. 스크림 아키텍처(SCREAM)에 이러한 개념이 반영되어 있다.

구체적인 구현에 의존하기보다는 추상화에 의존해야 한다. 제어할 수 없지만 변경될 수 있는 경게점에는 추상화 또는 인터페이스가 필요하다.

이렇게 하여 의존성을 역전시키는 것이다. 클라이언트는 인터페이스를 따라야 하기 때문에 코드에 적용할 수 밖에 없다.

추상화를 하고 의존석을 역전시크는 것은 좋은 습관이나 충분하지 않다.

모든 애플리케이션이 독립적이고 제어할 수 없는 것으로부터 격리되기를 원한다. 즉, 객체를 추상화하는 것 이상의 것으로 추상화 계층이 필요하다.

의존성 역전 원칙(DIP; dependecy inversion principle) 을 지키려면 표준라이브러리인 abc 모듈을 사용하여 인터페이스를 만드는 것이 좋다.

시스템에 대해서는 파이썬이 해준 것과 같은 기능이 없으므로 의존성 전체를 추상화해야 한다.

---

### - 소프트웨어 컴포넌트

: 

---

### - 패키지

: 파이썬 패키지는 소프트웨어를 배포보다 일반적인 방식으로 코드를 재사용하기 위한 편리한 방법이다.

빌드 패키지는 아티펙트(artifact) 저장소에 럽도르할 수 있으며 다른 아티펙트 저장소에서 이 패키지를 다운로드할 수도 있다.

이렇게 함으로써 코드의 재사용성을 높이고 개념적인 무결성을 얻을 수 있다.

- 파이썬 프로젝트 패키징의 핵심

1. 플랫폼에 독립적이며 로컬 설치에 의존하지 않는지 테스트하고 검증해야 한다.(소스 파일을 src/ 디렉토리에 놓음으로써 보다 수월하게 가능)
2. 단위 테스트를 패키지에 같이 배포X
3. 의존성 분리 - 프로젝특 ㅏ필요로 하는 것과 개발자가 필요로 하는 것은 다르다.
4. 가장 많이 요구되는 명령에 대해서는 진입점을 만드는 것이 좋다.

---

### - 컨테이너

: 컨테이너는 특정한 제약사항을 가지고 격리된 상태로 실행되는 프로세스.

구체적으로 말하면 도커(Docker) 컨테이너를 말한다.

도커 컨테이너는 애플리케이션(서비스나 프로세스)를 독립적인 컴포넌트로 관리한다.

컨테이너는 다른 형태의 소프트웨어 전달 수단이다. 코들르 재사용하고 특정 논리가 모여 있는 단일 장소로 사용하는 라이브러리나

프레임워크를 목표로 한다면 이전 섹션에서 살펴본 방식으로 파이썬 패키지를 만드는 것이 더 적합하다.

컨테이너의 경우 라이브러리가 아닌 애플리케이션을 생성시 사용한다.

그러나 애플리케이션이나 플랫폼이 반드시 전체 서비스를 의미하는 것은 아니다.

컨테이너를 만드는 이유는 작고 명확한 서비스를 나타내는 작은 컴포넌트를 만들기 위함이다.

도커가 애플리케이션 컨테이너화하는 유일한 기술 아니며 파이썬과 완전히 독립적인것을 명심하자.

도커 컨테이너는 실행할 이미지가 필요하며 이 이미지는 다른 기본(base) 이미지에서 만들어 진다.

그러나 우리가 만드는 이미지는 그 자체로 다른 컨테이너의 기본 이미지로 사용될 수 있다.

컨테이너는 애플리케이션이 표준적인 실행방법을 갖도록 도와 주며, 개발 프로세스를 수월하게 만든다.(환경에 따른 시나리오 재현, 세트 복제, 새로운 멤버의 개발환경 구축 등)

패키지가 코드를 재사용하고 조건을 통일하는 수단인데 반해 컨테이너는 애플리케이션의 다양한 서비스를 만드는 수단이다.

이들은 아키텍처에 관한 관심사의 분리(SoC)를 도와준다. 서비스는 애플리케이션의 나머지 부분과 독립적인 기능을 캡슐화하는 또 다른 종류의 컴포넌트이다.

이러한 컨테이너는 유지보수가 가능한 형태로 디자인되어야 한다.

책임을 명확하게 구분하여 해당 서비스의 변경으로 인해 애플리케이션의 다른 부분에 영향을 미치지 않도록 해야 한다.

---

### - 유스케이스

:

### - 코드

: 로직이 반복되고 다른 애플리케이션에서도 사용될 것으로 예상되는 경우 패키지를 만드는 것이 더 합리적이다.

왜냐하면 코드를 재사용할 수 있기 때문이다. 