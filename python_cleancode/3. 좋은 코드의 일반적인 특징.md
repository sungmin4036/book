클린 코드의 궁극적인 목표: 코드를 가능한 견고하고 결함은 최소화, 완전히 자명하도록 하는것.

더 높은 추상화 수준의 디자인 원칙에 중점을 둔다.

- 견고한 소프트웨어의 이해
- 작업 중 잘못된 데이터를 다루는 방법
- 새로운 요구 사항을 쉽게 받아들이고 확장할수 있는 유지보수가 쉬운 소프트웨어 설계
- 재사용 가능한 소프트웨어 설계
- 개발팀의 생산성을 높이는 효율적인 코드 작성

---

### 계약에 의한 디자인

계약에 의한 디자인(Design by Contract)란? 고나계자가 기대하는 바를 암묵적으로 코드에 삽입하는 대신 양측이 동의하는 계약을 먼저 한 다음, 게약을 ㅓㅇ겼을 경우는 명시적으로 왜 계속할 수 없는지 예외를 발생시키는것.

이 책에서 말하는 계약은 소프트웨어 컴포넌트 간의 통신 중에 반드시 지켜져야할 몇가지 규칙을 강제하는것.

계약은 주로 사전조건과 사후조건을 명시, 하지만 때로는 불변식과 부작용을 기술

```

- 사전조건(precondition)
: 코드가 실행되기 전에 체크해야 하는 것들
일반적으로 파라미터에 제공된 데이터의 유효성을 검사하지만 유효성 체크를 통해 부작용이 최소화된다는 점을 고려할때 유효성 검사를 많이 하는것이 좋다.
ex) DB, file 이전에 호출된 다른 메서드의 검사

- 사후조건(postcondition)
: 함수 반환 값의 유효성 검사가 수행. 사후조건 검증은 호출자가 이 컴포넌트에서 기대한 것을 제대로 받았는지 확인하기 위해 수행

- 불변식(invariant)
: 때로는 함수의 docstring에 불변식에 대해 문서화 하는것이 좋음. 불변식은 함수가 실행되는 동안에 일저앟게 유지되는 것으로 함수의 로직에 문제가 없는지 확인하기 위한것

- 부작용(side-effect)
: 선택적으로 코드의 부작용을 docstring에 언급
```

이상적으로는 이 몯느것들을 소프트웨어 컴포넌트 계약서의 일부로 문서화 하지만, 사전조건과 사후조건만 저수준(코드)레벨에서 강제

이렇게 계약에 의해 디자인시 오류 발생해도 쉽게 찾기 가능해진다.

또한, 잘못된 가정 하에 코드의 핵심 부분이 실행되는 것을 방지


==> 계약을 정의함으로써 런타임 시 오류 발생해도 코드의 어떤 부분이 손상되었는지 명확해짐.

또한 프로그램의 구조를 명확히 하는 목적으로도 사용


<br>
<br>

사전조건은 클라이언트와 연관, 클라이언트는 코드를 실행하기 위해 사전에 약속한 조건을 준수해야만한다.

사후조건은 컴포넌트와 연관 컴포넌트는 클라이언트가 확인하고 강제할 수 있는 값을 조장해야함.

=> 책임소재를 식속하게 파악 가능.

<br>
<br>

---

### 사전조건(precondition)

사전조건은 함수나 메서드가 제대로 동작하기 위해 보장해야 하는 모든것을 말한다.


- 유효성 검사를 어디서 하느냐에 따른 접근법

1. 관용적인(tolerant) 접근법 
: 클라이언트가 함수를 호출하기 전에 모든 유효성 검사하는것(함수가 어떤 값이라도 수용하기에 관용적인 접근법)

2. 까다로운(demanding) 접근법
: 함수가 자체적으로 로직을 실행하기 전에 검사하는것

일반적으로 가장 안적하고 견고한 방법이며 업계에서 가장 널리 쓰이는 방법은 `까다로운 접근방법`

\# 중복 제거 원칙 : 사전조건 검증을 양쪽에서 하지 말고 오직 어느 한쪽에서만 해야한다는것.

즉, 검증 로식을 클라이언트에 두거나 함수 자체에 두어야 한다.

<br>
<br>

---

### 사후조건(postcondition)

사후조건은 메서드 또는 함수가 반환된 후의 상태를 강제하는 계약의 일부

함수 또는 메서드가 적절한 속성으로 호출시 사호조건의 특정속성이 보존되도록 보장해야함.

<br>
<br>

---

### 방어적(defensive) 프로그래밍

방어적 프로그래밍은 계약에의한 디자인과는 다소 다른 접근 바익

계약에서 예외를 발생시키고 실패하게 되는 모든 조건을 기술하는 대신 객체, 함수 또는 메서드와 같은 코드의 모든 부분을 유효하지 않을 것으로부터 스스로 보호 가능하게함.

방어적 프로그래밍의 주요 주제는

1. 예상할 수 있는 시나리오의 오류를 처리하는 방법 - 에러 핸들링(error handling)
2. (불가피한 조건에 의해서) 발생하지 않아야 하는 오류를 처리하는 방법 - 어썰션(assertion)

---

### 에러 핸들링

오류가 발생하기 쉬운 상황에서 에러 핸들링 프로시저를 사용, 일반적으로 데이터 입력 확인 시 자주 사용

주요목적은 예상되는 에러르에 대해서 실행을 계속할수 있으지 아니면 극복할수 없는 오류여서 프로그램을 중단할지를 결정

에러 처리 방법의 일부

- 값 대체(substitution)
- 에러 로깅
- 예외 처리

---

#### - 값 대체

: 일부 시나리오에서는 오류가 있어 소프트웨어가 잘못된 값을 생성하거나 전체가 종료될 위험이 있을 경우 결과 값을 안전한 다른 값으로 대체 한다. \

잘못된 결과를 정합성을 깨지않는 다른 값으로 대체

기본 값, 잘 알려진 상수, 초기 값으로 바꾸는 것

ex) 덧셈을 하려는 경우 0을 반환하면 결과에 영향을 미치지 않게 된다.

소프트웨어 프롤그램은 예상치 못한 상황에서도 실패하지 않아야 견고하다고 할수 있다.

그러나 무조건 실패하지 않는 것이 항상 옳은 것은 X

<br>

애플리케이션이 민감하고 중요한 정보를 다루는 경우부정확한 결과를 그대로 재보낼 수 없다. 이런 경우는 잘못된 결과를 생산하여

프로그램을 폭파하는 것보다는 정확성을 선택해야한다.

약간 다른 방향으로 안전한 방법은 제공되지않는 데이터에 기본 값을 사용하는것.

일반적으로 누락된 파라미터를 기본 값으로 바꾸어도 큰 문제가 없지만 오류가 있는 데이터를 유사한 값으로 대체하는것은 위험하며, 일부 오류를 숨겨버릴수 있다.

---

#### - 예외 처리

: 잘못되거나 누락된 입력 데이터가 있는 경우 이전 섹션에서 언급한 것과 같이 복구 처리가 가능한 경우가 있음

그러니 어떤 경우에는 에러가 발생하기 쉽다는 가정으로 계속 실행 보단느 실행을 멈추는 것이 더 좋음.

이 경우 호출자에게 실패 했음을 알리는 것이 좋은 선택

함수는 심각한 오류에 대해 명확하고 분명하게 알려줘서 적절하게 해결할 수 있도록 해야 한다. 이것이 바로 `예외 메커니즘` 이다.

예외는 대개 호출자에게 잘못을 알려주는 것이다. 예외는 캡슐화를 약화시키기 떄문에 신중하게 사용해야 한다.

함수에 예외가 많을수록 호출자가 호출하는 함수에 대해 더 많은 것을 알아야 한다. 그리고 너무 많은 예외를 발생시키면 문맥에서 자유롭지 않다는것 의미

왜냐하면 호출할 때마다 발생 가능한 부작용을 염두해 두고 문맥을 유지해야 함

예외가 너무 많이 발생하면 여러 개의 작은 것으로 나눠야한다는 신호일 수도 있다.

<br>

---

### - 파이썬에서 예외 관련 권장 사항

1. 올바른 수준의추상화 단계에서 예외 처리 - 에러처리를 올바른 메서드 넣을것
2. Traceback 노출 금지 - 특정 문제를 나타내는 예외가 있는 경우 문제를 효율적으로 해결위해 로그 남기는것은 중요하지만 세부사항은 절대 사용자에게 보여서는 안된다.
3. 비어있는 except 블록 지양 - 문제를 숨기고 유지보수를 더 어렵게 만듬

두가지 대안 방법( 두 항목 동시 적용하면 best)

3-1 보다 구체적인 예외를 사용한다. 실제로 코드가 너무 광범위한 예외를 사용ㅎ는 경우 린팅 도구나 IDE 에서 경고 표시
3-2 except 블록에서 실제 오류 처리

4. 원본 예외 포함 - 오류 처리 과정에서 다른 오류를 발생시키고 메시지를 변경 가능. 이경우 원래 예외를 포함하는것이 좋다.

```
class InternalDataError(Exception):
    """ 업무 도메인 데이터의 예외"""

def process(data_dictionary, record_id):
    try:
        return data_dictionary[record_id]
    except KeyError as e:
        raise InternalDataError("Record not present") from e
```

`예외 타입 변경시 항상 raise<e> from <o> 구문 사용`

---

### 파이썬에서 어설션 사용하기

: 어설션은 절대로 일어나지 않아야 하는 사오하엥서 사용, assert 문에 사용된 표현식은 불가능한 조건을 의미.

즉, 이 상태가 된다는 건 소프트웨어에 결함이 있음을 의미

어설션은 잘못된 시나리오에 도달할 경우 프로그램이 더 큰 피해를 입지 않도록 하는것 때로는 잘못된 가정 하에 처리를 계속 진행하는거 보단 프로그램 중단하는것이 더 좋다.

이러한 이유로 어설션을 비즈니스 로직과 섞거나 소프트웨어의 제어 흐름 메커니즘으로 사용해서는 안된다.

어설션에 실패하면 반드시 프로그램을 종료시켜야 한다.

```
try:
    assert condition.holds(), "조건에 맞지 않음"
except AssertionError:
    alternative_procedure()
```

assert 처리시 문장이 함수이면, 안좋다. 함수 호출은 부작용을 가질수 있으며 항상 반복 가능하지도 않다.(다시 호출시 같은 결과 보장X)

또한 디버거 사용시 해당 라인에 중지하여 오류 결과 편리하게 볼수 없음.

```
result = condition.holds()
assert result > 0, "에러 {0}".format(result)
```
<br>
<br>

---

### 관심사의 분리

책임이 다르면 컴포넌트, 계층 또는 모듈로 분리 되어야 한다.

프로그램의 각 부분은 기능의 일부분(관심사)에 대해서만 책임을 가지며, 나머지 부분에 대해서는 알 필요 없다.

소프트웨어에서 관심사를 분리하는 목표는 파급 효과를 최소화하여 유지보수성을 향상시키는것.

```
파급(ripple) 효과는 어느 지점에서의 변화가 전체로 전파된느것 의미
```

소프트웨어는 쉽게 변경될 수 이썽야 한다. 애플리케이션의 나머지 부분에 대한 영향성을 최소화하면서 코드를 수정하거나 리팩토링을 하고싶다면 적절한 `캡슐화`필요

---

#### - 응집력(cohesion)과 결합력(coupling)

- 응집력이란? 객체가 작고 잘 정의된 목적을 가져야 하며 가능하며 작아야 한다는것을 의미.

응집력이 높을수록 더 유용하고 재사용성이 높아지므로 더 좋은 디자인

- 결합력이란? 두 개 이상의 객체가 서로 어떻게 의존하는지를 나타낸다. 종속성은 제한을 의미

\# 낮은 재사용성: 만약 어떤 함수가 특정 객체에 지나치게 의존하는 경우 또는 너무 많은 파라미터를 가진 경우 이 함수는 해당 객체에 결합되게 된다. 즉 다른 상활에서는 이 함수를 사용하기가 매우 어렵다. 그렇게 하려면 매우 제한적인 인터페이스를 따르는 적절한 파라미터를 찾아야한다.

\# 파급(ripple)효과: 너무 가깝게 붙어 있게 되면 두 부분중 하나를 변경하면 다른 부분에도 영향을 미친다.

\# 낮은 수준의 추상화: 두 함수가 너무 가깝게 고나련되어 있으면 서로 다른 추상화 레벨에서 문제를 해결하기 어렵기 떄문에 관심사가 분뢰되어 있다고 보기 어려움
---

#### - 개발 지침 약어

- DRY/OAOO
: DRY(Do not Repeat Yourself) 와 OAOO(Once and Only Once)는 중복을 반드시 피해야 한다.

코드에 있는 지식은 단 한번, 단 한곳에 정의되어야 한다. 코드 변경시 수정이 필요한 곳은 한곳이어야한다.

- 바람직 하지 않은 이유

1. 오류 발생 쉬움: 어떤 로직이 코드 전체에 여러번 반복되어 있는데 수정한다고 가정시 인스턴스의 하나라도 빠뜨리면 버그가 발생
2. 비용이 비쌈: 한번 정의시 보다 여러곳에서 정의했을 경우 변경하는데 더많은 시간이 소요
3. 신뢰성 떨어짐: 문맥상 여러 코드를 변경하는 경우사람이 모든 인스턴스 위치 기억해야함. 단일 데이터 소스가 아니므로 데이터의 완결성 떨어짐

중복은 기존 코드의 지식을 무시 또는 잊어버림으로 발생.

<br>
<br>
---

- YAGNI
: YAGNI(You Ain't Gonna Need it)는 과잉 엔지니어링을 하지 않기 위해 솔루션 작성 시 계속 염두에 둬야 하는 원칙

우리는 프로그램을 쉽게 수정하기를 원하므로 미래 보장성이 높기를 바란다. 그러나 미래 요구사항을 예측하기란 쉽지않다.

현재의 요구사항을 잘 해결하기 위한 소프트웨어를 작성하고 가능한 자중에 수정하기 쉽도록 작성하는것이 best

<br>
<br>
---

- KIS
: KIS(Keep It Simple) 소프트웨어 컴포넌트를 설계할 때 과잉 엔지니어링을 피해야 한다.

문제를 올바르게 해결하는 최소한의 기능을 구현하고 필요한 것 이상으로 솔루션을 복잡하게 만들지 않도록 해야한다.

디자인이 단순할수록 유지 관리가 쉽다.

<br>
<br>
---

- EAFP/LBYL
: EAFP(Easier to Ask Forgiveness than Permission) 허락보다는 용서를 구하는 것이 쉽다. 

LBYL(Look Before You Leap) 도약하기 전에 살피라

EAFP는 일단 코드를 실행하고 실제 동작하지 않을 경우에 대응하라는 뜻이다. 일반적으로 코드를 실행하고 발생 한 예외를 catch 하고 except 블록에서 바로잡는 코드를 실행하게 된다.

LBYL는 반대로, 도약하기 전에 먼저 무엇을 사용하려고 하는지 확인하라는 뜻이다.

ex) 파일 사용전에 먼저 파일 사용할수 있는지 확인하는것

```
if os.path.existis(filename):
    with open(filename) as f:
    ...
```

이것은 프로그래밍 언어에서 유용하지만 파이썬스러운 방식X, 파이썬은 EAFP로 만들어 졌음.

```
try:
    with open(filename) as f:
    ...
except FileNotFoundError as e:
    logger.error(e)
```

<br>
<br>
---

### 컴포지션과 상속
: 상속은 코드 재사용으로 많이 사용하지만 결합력(coupling)을 높이기 때문에 사용할떄 주의를 요함

- 상속이 좋은경우

: 상속은 부모 클래스의 메서드로 공짜로 전수 받을 수 있는 장점이 있지만, 그러나 모든 것을 새로운 클래스로 가져왔기 때문에 새로운 정의에 너무 많은 기능을 추가하게 되는 단점도 있다.

하위 클래스 만들때 모든 메서드르를 실제로 사용할 것인지 생각해보고, 메서드를 필요로 하지 않고 재정의 하거나 대체해야 한다면 다음과 같은 이유로 설계상의 실수라고 할수 있다.

>> - 상위 클래스는 잘 정의된 인터페이스 대신 막연한 정의와 너무 많은 책임을 가졌다
>> - 하위 클래스는 확장하려고 하는 상위 클래스의 적절한 세분화가 아니다.

<br>

#### 상속을 잘 선택한 경우

- 상속을 잘 사용한 좋은 예시
: public 메서드와 속성 인터페이스를 정의한 컴포넌트가 있다. 그리고 이 클래스의 기능을 그대로 물려 받으면서 추가 기능을 더하려는 경우 또는 특정 기능을 수정하려는 경우

- 파이썬 표준 라이브러리에서의 상속의 종은 예시
: 어떤 객체에 인터페이스 방식을 강제하고자  떄 구현을 하지 않은 기본 추상 클래스를 만들고, 실제 이 클래스를 상속하는 하위 클래스에서 적절한 구현을 하도록 하는것.

- 예외 에서의 예시
: 파이썬 표준 예외는 Exception에서 파생된다. 이것은 except Exception: 같은 일반 구문을 통해 모든 에러를 catch 할수 있게 해준다.

중요한 것은 모든 예외가 Exception에서 상속받은 클래스 라는것 이것은 requests와 같은 잘 알려진 라이브러리에서도 잘 작동한다.

ex) HTTPError는 RequestException를 상속받고, RequestException은 IOError를 상속받는다.

<br>
<br>

### 상속 안티패턴
: 부모 클래스는 새 파생 클래스의 공통 정의의 일부가 된다. 상속된 메서드가 새로운 클래스의 일부가 되기 떄문이다. 이런 이유로 클래스의 public 메서드는 부모 클래스가 정의 하는것과 일치해야됨.

ex) BaseHTTPRequestHandler에서 파생된 클래스가 handle()이라는 메서드 구현시 부모 클래스의 일부를 오버라이딩한것

- 파이썬에서의 전형적인 안티패턴 구조
: 도메인 문제를 해결하기위해 적절한 데이터 구조를 만든 후 이 데이터 구조를 사용하는 객체를 만들지 않고 데이터 구조 자체를 객체로 만드는 경우

```잘못된 상송의 예시

class TransactionalPolicy(collections.UserDict):
    
    def change_in_policy(self, customer_id, **new_policy_data):
        self[customer_id].update(**new_policy_data)

>>> policy["client001"]
{'fee': 1000,., 'expireation_data': datetime.datetime(2020, 1, 3, 0,0)}
>>> policy.change_in_policy("client001", expireation_date+datetime(2020, 1, 4))
>>> policy["clinet001"]
{'fee': 1000,., 'expireation_data': datetime.datetime(2020, 1, 4, 0,0)}
```

처음에는 원하는 기능을 수행하는 인터페이스르 갖게 되지만, 비용 측면에서는 이 클래스에는 불필요한 수많은 메서드가 포함된다.

```
>>> dir(policy)
'chagne_in_policy', 'clear', 'copy', 'date', 'fromekys', 'get', 'items', ...
```

이 디자인의 주요 문제점

1. 계층 구조가 잘못됨
: 기본 클래스에서 새 클래스를 만드는 것은 말 그대로 그것이 개념적으로 확장되고 세부적인 것이라는 것을 의미. TranscationalPolicy라는 이름만 보고 어떻게 사전 타입이라는것을 알수없음.

사용자가 객체의 public 인터페이스를 통해 노출된 public 메서드들을 확인하게 되면 특이하게 전문화된 이상한 계층구조로 느끼게 될 가능성이 큼.

2. 결합력(coupling) 문제
: TransactionPolicy는 이제 사전의 모든 메서드를 포함한다. TransactionPolicy에 pop() 또는 items()와 같은 메서드가 실제로 필요 하지 않다.

이것들은 public 메서드 이므로 이 인터페이스의 사용자는 부작용이 있을지도 모른는 이 메서드를 호출 할 수 있다. 추가로 사실 사전 타입을 확장함으로 얻은 이득도 별로 없다.

현재 정책에 영향을 받는 모든 고객을 업데이트 하는 메서드가 유일한 추가 메서드로서 부모 클래와는 상관이 없다.

이것이 구현 객체를 도메인 객체와 혼합할 떄 발생하는 문제.

사전은 특정 유형의 작업에 적합한 객체 또는 데이터 구조로서 다른 데이터 구조와 마찬가지로 트레이드오프가 있다.

TransactionPolicy는 특정 도메인의 정보를 나타내는 것이므로 해결하려는 문제의 일부분에사용되는 엔티티여야만 함

온전히 기본 클래스에 추가되는 그리고 보다 특화된 것을 구현할 떄만 확장을 해야한다.

==> `컴포지션` 활용하기

TrnsactionalPolicy 자체가 사전이 되는것이 아닌 사전을 확용하는것. 사전을 private 속성에 저장하고 __getitem__()으로 사전의 프록시를 만들고 나머지 필요한 puiblic 메서드를 추가적으로 구현하는것.

```
class TransactionalPolicy:

    def __init__(self, policy_data, **extra_dataA:
        self._data = {**policy_data, **extra_data}

    def change_in_policy(self, customer_id, **new_policy_data):
        self._data[customer_id].update(**new_policy_data)

    def __getitem__(self, customer_id):
        return self._data[customer_id]

    def __len__(self):
        return len(self._data)
```

이 방법으로 개념적으로 정확할 뿐만 아니라 확장성도 뛰어나다.

현재 사전인 데이터 구조를 향후 변경해도 인터페이스만 유지하면 사용자는 영향 받지X

이는 결합력을 줄이고 파흡 효과를 최소화, 보단 나은 리펙토링을 허용하고, 코드를 유지 관리하기 쉽게 만든다.

<br>
<br>

#### 파이썬의 다중상속

- 메서드 결정순서(MRO)
:  최상위 클래스는 module_name 속성을 가지며 __str__ 메서드를 구현한다.

ConcreateModuleA12 구체 클레스를 예를 들면 BaseModule1과 BaseBodule2를 확장하여 각각은 BaseModule 에서 __str__ 을 구현하다. 둘중 A12의 메서드가 되는가?

클래스의 속성 값을 통해 명확하게 확인이 가능하다.

```
class BaseModule:
    module_name = "top"

    def __init__(self, module_name):
        self.name = module_name

    def __str__(self):
        return f"{self.module_name}:{self.name}"

class BaseModule1(BaseModule):
    module_name = "module-1"

class BaseMoudle2(BseModule):
    module_name = "module-2"

class BaseMoudle3(BseModule):
    module_name = "module-3"

class ConcreateModuleA12(Basemodule1, Basemodule2):

class ConcreateModuleA12(Basemodule2, Basemodule3):

===========================================

>>> str(ConcreateA12("test"))
    'module-1:test'
```

충돌이 발생하지 않고, 파이썬은 C3 lineariztion 또는 MRO 라는 알고리즘을 사용하여 이 문제를 해결한다.

구체적으로 클래스에게 결정 순서를 물어보는 것도 가능.

```
>>> [cls.__name for cls in ConcreateModuleA12.mro()]
['ConcreateMudleA12', 'BaseMoudle1', 'BaseMoudle2', 'BaseMoudle', 'object']
```

<br>

- 믹스인(mixin)
: 코드를 재사용하기 위해 일반적인 행동을 캡슐화해놓은 기본 클래스.

일반적으로 이 자체로는 유용하지 않으며, 대부분 클래스에 정의된 메서드나 속성에 의존하기 때문에 이 클래스만 확장해서는 확실히 동작X

보통 다른 클래스와 다중 상속하여 믹스인에있는 메서드나 속성 사용

```
class BaseTokenizer:
    def __init__(self, str_token):
        self.str_token = str_token

    def __iter__(self):
        yield from self.str_token.split("-")

==============
>>> tk = BaseTokenizer("28a2320b-fd3f-4627")
>>> list(tk)
['28a2320b', 'fd3f', '4627']
```

기본 클래스 변경 없이 값을 대문자로 변환. 새로운 클래스를 만들수 있지만, 이미 BaseToeknizer를 확장했고 모든 클래스를 바꾸지 않는 가정하에 계층 구조에 클래스 혼합

```
class UpperIterableMixin:
    def __init__(self):
        return map(str.upper, super().__iter())

    class Tokenizer(UpperIterableMixin, BaseTokenzer):
        pass
```

이러한 유형의 혼합은 일종의 데코레이터 역할을 한다.

Tokenizer는 믹스인에서 __iter__를 호출하고 다시 super() 호출을 통해 다음 클래스 BaseTokenizer에 위임.

<br>
<br>

### 파이썬의 함수 인자 동작방식

- 인자는 함수에 어떻게 복사되는가
: 모든 인자가 값에 의해 전달(passed by a value), 즉 함수에 값을 던달하면 함수의 서명에 있는 변수에 할당되고 나중에 사용.

인자를 변경하는 함수는 인자 타입에 따라 다른 결과 낼 수 있다.

변경 가능한(mutable) 객체를 전달하고 함수에서 값을 변경하면 함수 반환 시 실제 값이 변경되는 부작용 생길 수 있다.

```
>>> def function(arg):
    arg += " in function"
        print(arg)

>>> immutable = "hello"
>>> function(immutable)

hello in function

>>> mutable = list("hello")
>>> immutalbe
'hello'

>>> function(mutable)
['h','e','l','l','o','','i','n...]

>>> mutable
['h','e','l','l','o','','i','n...]
```

첫 번쨰 인자(문자열)을 전달하면 함수의 인자에 할당, strign 객체는 불변형(immutable) 타입이므로 "arg += <expression>" 문장은 "arg + <expression>" 형태로 새로운 객체를 만들어서 arg에 다시 할당.

이 시점에서 arg는 단지 함수 스코프 내에 있는 로컬 변수이며, 호출자의 원래 변수와는 아무런 관련이 없다.

반면에 변형(mutable) 객체인 리스트를 전다랗면 해당 문장은 다른 의미를 갖는다.(실제로는 llist의 extend() 호출하는것과 같음)

이 연산자는 원래 리스트 객체에 대한 참조를 보유하고 있는 변수를 통해 값을 수정하므로 함수 외부에서도 실제 값 수정 가능

그러나 이러한 유형의파라미터를 사용하면 예상치 못한 부작용 유발이 가능하여 주의 요함 ==> 이러한 방식으로 변경하는것은 옳은 상황이 아니며, 가급적 피하고 다른 대안 권함.

<br>

\# `함수 인자를 변경하지 않아야 한다. 최대한 함수에서 발생할 수 있는 부작용 회피`


<br>

- 가변 인자
: 가변 인자를 사용하려면 해당 인자를 패킹(packing)할 변수의 이름 앞에 별표(*)를 사용한다. 이것은 파이썬의 패킹 매커니즘에 따른 것.

3개의 위치 인자를 갖는 함수가 있다고 가정시, 함수에서 기대하는 순서대로 리스트의 값을 편리하게 전달할 수 있다.

첫번쨰 요소에 list[0], 두번째 ㅇ소에 list[1] ... 이것은 전혀 파이썬스러운 코드X

패킹 기법을 사용하면 하나의 명령어로 전달 가능해진다.

```
>>> def f(first, second, third):
    print(first)
    print(second)
    print(third)

>>> l = [1, 2, 3]
>>> f(*l)
1
2
3
```

패킹 기법의 장점은 다른 방향으로도 동작 가능 하다.

```
>>> a, b, c = [1, 2, 3]
>>> a 
1
>>> b
2
>>> c
3
```

부분 적인 언패킹도 가능

```
def show(e, rest):
    print("요소: {0} - 나머지: {1}".format(e, rest))

>>> first, *rest = [1, 2, 3, 4, 5]
>>> show(first, rest)
요소: 1 - 나머지: [2, 3, 4, 5]

>>> last, *rest = range(6)
>>> show(last, rest)
요소: 5 - 나머지:[0, 1, 2, 3, 4]

>>> first, *middle, last = range(6)
>>> first
0
>>> middle
[1, 2, 3, 4]
>>> last
5

>>> first, last, *empty = (1, 2)
>>> first
1
>>> last
2
>>> empty
[]
```

변수 언패킹의 좋은 예시는 반복

```
def bad_users_from_rows(dbrows) -> list:
    """ 파이썬스럽지 않은 잘못된 사용 예시"""
    return [User(row[0], row[1], row[2] for row in dbrows


def users_from_rows(dbrows) -> list:
    """ 파이썬 스러운 사용 예시"""
    User(user_id, first_name, last_name)
    for (user_id, first_name, last_name) in dbrows
    ]
```
무엇을 뜻하는지 한눈에 확인 가능하여 훨씬 읽기 쉬워진다.


표준 라이버르리에서의 사용 에시는 max 함수에서 발견할수 있음

```
max(...)
    max(iterable, *[, default=obj, key=func]) -> value
    max(arg1, arg2, *args, *[,key=func]) -> value
```

비슷한 표기법으로 이중 별표(**) 키워드 인자에 사용 가능, 사전에 이중 별표를 사용하여 함수에 전달하면 파라미터의 이름으로 키를 사용하고, 파라미터의 값으로 사전의 값을 사용한다.

```
    function(**{"key": "value"})
```

반대로 이중 별표를 시작하는 파라미터를 함수에 사용하면 반대 현상이 발생. 키워드 인자들이 사전으로 패킹

```
>>> def function(**kwargs):
    print(kwargs)

>>> function(key="value")
{'key': 'value'}
```


<br>

### 함수 인자의 개수
: 너무 많은 인자를 사용하는 함수나 메서드가 왜 나쁜 디자인의 징후와 그 해결책

일반적인 소프트웨어 디자인의 원칙을 사용, 즉 구체화(reification)하는것

전달하는 모든 인자를 포함하는 새로운 객체를 만드는 것이다. 이는 아마 추상화 빼먹었기 떄문, 여러 인자를 새로운 객체로 압축하는 것은 파이썬만의 고유한 솔루션이 아니라 모든 프로그래밍 언어에서 적용하는 방법

또 다른 옵션은 가변 인자나 키워드 인자를 사용하여 동적 서명을 가진 함수를 만드는것. 이것은 파이썬 스러운 방법이지만 남용하는것은 안좋음.

이유는 매우 동적이여서 유지보수가 어려움.

서명에 관계없이 (파라미터가 올바르게 사용되었다 해도) 만약 피러미터의 값에 대응하여 너무 만흥ㄴ 것들을 함수에서 처리하고 있다면 여러 작은 함수로 분리하라는 사인

`함수는 오직 한 가지 일만 해야 한다.`

<br>

-함수 임자와 결합력 
: 함수 서명의 인수가 많을수록 호출자 함수와 밀접하게 결합될 가능성이 커진다.

ex) f1과 f2 두 함수가 있고, f2는 5개의 파라미터 사용한다.

f2가 더 많은 파라미터를 사용할수록 호출자는 정상 동작을 위한 모든 정보를 수집하는것이 점점 더 어려워 진다.

이제 f1이 f2호출을 위한 모든 정보를 갖고 있을경우, f2는 추상화 부족할 가능성이 높으며 f1은 f2가 필요로 하는 모든 것을 가지고 있기 떄문에 f2 내부적으로 무엇 하는지 알아낼수 있으며, 거의 자체적으로 수행 가능

또, f2는 다른 환경에서 사용하기가 어려워 f1에서만 유용하기 떄문에 재사용성 떨어짐

`함수가 보다 일반적인 인터페이스를 제공하고 더 높은 수준의 추상화로 작업 가능하다면 코드는 재사용성이 높아진다.`

이것은 클래스의 __init__ 메서드를 포함하여 모든 종류의 함수와 객체 메서드에 적용된다.

<br>

- 많은 인자를 취하는 작은 함수의 서명
: 너무 많은 파라미터를 사용하는 함수를 리팩토링 하는 방법

```
track_request(request.headers, request.ip_addr, request.request_id)
```
위와 같은경우 모든 파라미터가 request와 과련있다는걸 알수있다. 이런경우 request를 파라미터로 전달하는것으로 변경하면 코드를 크게 향상시킨다.

```
track_request(requst)
```

이와 같이 파라미터를 전달할 것을 권장하지만 변경 가능한 객체를 전달시 부작용에 주의 요함

`함수는 전달받은 객체를 변경해서는 안 된다.`

1. 개체를 무언가를 바꾸고 싶다면 전달된 값을 복사한 다음 새로운 수정본을 반환하는것이 나은 대안
2. 변경 불가능한 객체를 사용하여 부작용 최소화 한다.
3. 파라미터 그룹핑

이전 예제에서 파라미터는 이미 그룹화되었기 떄문에(request 객체) 그룹을 사용하지 않는다.

그러나 이렇게 분명하지 않은 경우는 컨테이너처럼 하나의 객체에 파라미터를 담기 원하는 경우도 있다. 이럴때는 그룹핑하는 것이 타당한다.

`구체화(reify)`를 하는 것으로 디자인에서 누락된것 추상화 하는 작업.

인자가 많은데 *args 또는 *kwargs를 사용하면 더 이해하기 어려운 상황 만들수 있다.

단점은 서명을 잃어버린다는 것과 가독성의 상실한다.

<br>
<br>

### 소프트웨어 디자인 우수 사례 결론

: 좋은 소프트웨어 디자인 이란? 소프트웨어 엔지니어링 우수 사례를 따르고 언어의 기능을 제공하는 대부분의 장점을 이용한 디자인.

<br>

- 소프트웨어의 독립성(orthogonality)
: 직교(orthogonality)는 수학에서 두 요소가 독립적이라는것 의미.

`모듈, 클래스, 함수를 변경하면 수정한 컴포넌트가 외부 세계에 영향을 미치지 않아야 한다.`

물론, 항상 가능한것도 아니지만 가능한 영향을 최소화 하려고 시도해야한다.

소프트웨어의 런타임 구조 측명에서 직교성은 변경(또는 부작용)을 내부 문제로 만드는 것이라고 할 수 있다.

코드의 두 부분이 독립적이라는 것은 다른 하나에 영향을 주지않고 변경할 수 있다는 것을 뜻한다.

이는 변경된 부분의 단위 테스트가 나머지 단위 테스트와도 독립적이라는 것을 뜻한다.

<br>
<br>

### 코드 구조

: 여러 정의(클래스, 함수, 상수 등)가 들어있는 큰파일을 만드는것은 조지 않으므로 권장 하지 않는다.

좋은 코드라면 유사한 컴포넌트 끼리 정리하여 구조화 해야한다.

만약 코드의 열버ㅓ 부분이 해당 파일의 정의에 종속되어 있어도 전체적인 호환성을 유지하면서 패키지 나누기 가능한다.

==> __init__.py 파일을 가진 새 디렉토리로 만드는것.

1. 이 파일과 함께 특정 정으 를 포함하는 여러 파일을 생성한다.
2. 각각의 기준에 맞춰 보다 적은 클래스와 함수를 갖게 된다.
3. __init__.py 파일에 다른 파일에 있던 모든 정의를 가져옴으로써 호환성 보장 가능, 뿐만 아니라 __all__ 변수에 익스포트가 가능하도록 표시도 가능

- 장점
1. 모듈을 임포트시 구문을 분석하고 메모리에 로드할 객체 줄어듬
2. 의존성이 줄었기 때문에 더 적은 모듈만 가져오면 된다.



---

계약에 의한 디자인과 방어 프로그래밍에 의한 디자인 모두 어설션 올바르게 사용하는것 중요.

어떻게 사용돼야하는지 염두하고 프로그램의 흐름을 제어하는 용도로 하용하면 안됨. 예외에서 처리해서도 안됨.

예외는 언제 사용하는지 아는 것이 중요하며, 제어 흐름(go-to)의 수단으로 예외를 사용하면 안 된다.

객체 지향 디자인에서 상속 또는 컴포지션은 선택하는 것이 아닌 더 나은 옵션을 사용하는것.

